<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meet with Sound</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/geofire-common@6.0.0/dist/index.min.js"></script>
  <style>
    #map { height: 500px; width: 100%; }
    #status { text-align: center; margin: 10px; }
    #permission-message { text-align: center; color: red; display: none; }
    #retry-button, #beacon-button { display: block; margin: 10px auto; padding: 10px; }
    .hidden { display: none; }
    #nearby-users { margin: 10px; }
    #message-input { width: 80%; padding: 5px; }
    #message-list { margin: 10px; max-height: 200px; overflow-y: auto; }
    /* Blinking effect for your position */
    .blinking-dot {
      width: 18px;
      height: 18px;
      background: red;
      border-radius: 50%;
      border: 2px solid white;
      position: relative;
    }
    .blinking-marker .blinking-dot {
      animation: flash 1s infinite;
    }
    @keyframes flash { 50% { opacity: 0; } }
  </style>
</head>
<body>
  <div id="status">Getting your location...</div>
  <div id="permission-message">
    <h2>Location Permission Required</h2>
    <p>This app needs your location to work properly.</p>
    <p>Please allow location access in your browser settings.</p>
    <button id="retry-button">Retry Location</button>
  </div>
  <button id="beacon-button" class="hidden">Beacon OFF</button>
  <div id="map"></div>
  <div id="nearby-users" class="hidden">
    <h3>Nearby Users (within 1 km)</h3>
    <ul id="nearby-users-list"></ul>
  </div>
  <div id="message-list"></div>
  <input id="message-input" type="text" placeholder="Type a message..." class="hidden">
  <button id="send-message" class="hidden">Send</button>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getFirestore, collection, doc, setDoc, onSnapshot, GeoPoint, query, orderBy, startAt, endAt, getDocs } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js';
    import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
    import 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';

    const firebaseConfig = {
      apiKey: "AIzaSyDC6w15EQdfuBTZHlpvoxmaL5ISEgbFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.firebasestorage.app",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const map = L.map('map').setView([0, 0], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    let userPosition = null;
    let userMarker = null;
    let otherUsers = {};
    let beaconOn = false;
    let audioContext = null;
    let oscillator = null;
    let userId = null;
    let selectedRecipientId = null;
    let currentNearbyUserCount = 0; // Keep track of last nearby user count

    const statusDiv = document.getElementById('status');
    const permissionMessage = document.getElementById('permission-message');
    const retryButton = document.getElementById('retry-button');
    const beaconButton = document.getElementById('beacon-button');
    const nearbyUsersList = document.getElementById('nearby-users-list');
    const messageInput = document.getElementById('message-input');
    const sendMessageButton = document.getElementById('send-message');
    const messageList = document.getElementById('message-list');

    signInAnonymously(auth).then(userCredential => {
      userId = userCredential.user.uid;
      requestLocation();
    }).catch(error => console.error('Auth error:', error));

    function requestLocation() {
      statusDiv.textContent = 'Getting your location...';
      permissionMessage.style.display = 'none';
      navigator.geolocation.watchPosition(
        position => {
          userPosition = [position.coords.latitude, position.coords.longitude];
          statusDiv.className = 'hidden';
          beaconButton.className = '';
          updateUserLocation();
          if (beaconOn) {
            map.setView(userPosition, 15);
            fetchNearbyUsers();
          }
        },
        error => {
          statusDiv.className = 'hidden';
          permissionMessage.style.display = 'block';
          console.error('Location error:', error);
        },
        { enableHighAccuracy: true }
      );
    }

    async function updateUserLocation() {
      if (userPosition) {
        const hash = geofire.geohashForLocation(userPosition);
        await setDoc(doc(db, 'users', userId), {
          location: new GeoPoint(userPosition[0], userPosition[1]),
          geohash: hash,
          beaconOn: beaconOn,
          name: `User_${userId.substring(0, 5)}`,
          timestamp: new Date()
        });

        // Create or update blinking marker for the user
        if (userMarker) {
          userMarker.setLatLng(userPosition);
          userMarker.setIcon(L.divIcon({
            className: beaconOn ? 'blinking-marker' : '',
            iconSize: [20, 20],
            html: '<div class="blinking-dot"></div>',
          }));
        } else {
          userMarker = L.marker(userPosition, {
            icon: L.divIcon({
              className: beaconOn ? 'blinking-marker' : '',
              iconSize: [20, 20],
              html: '<div class="blinking-dot"></div>',
            })
          }).addTo(map);
        }
        // Zoom in whenever Beacon is ON and location is updated
        if (beaconOn && userPosition) {
          map.setView(userPosition, 15);
        }
      }
    }

    beaconButton.addEventListener('click', () => {
      beaconOn = !beaconOn;
      beaconButton.textContent = `Beacon ${beaconOn ? 'ON' : 'OFF'}`;
      updateUserLocation();
      if (beaconOn) {
        if (userPosition) map.setView(userPosition, 15); // Zoom in immediately on Beacon ON
        fetchNearbyUsers();
        nearbyUsersList.parentElement.className = '';
        messageInput.className = '';
        sendMessageButton.className = '';
      } else {
        stopBeep();
        currentNearbyUserCount = 0;
        nearbyUsersList.innerHTML = '';
        nearbyUsersList.parentElement.className = 'hidden';
        messageInput.className = 'hidden';
        sendMessageButton.className = 'hidden';
      }
    });

    retryButton.addEventListener('click', requestLocation);

    async function fetchNearbyUsers() {
      if (!userPosition || !beaconOn) {
        updateBeep(0);
        return;
      }
      const radiusInM = 1000;
      const bounds = geofire.geohashQueryBounds(userPosition, radiusInM);
      const promises = [];
      for (const b of bounds) {
        const q = query(
          collection(db, 'users'),
          orderBy('geohash'),
          startAt(b[0]),
          endAt(b[1])
        );
        promises.push(getDocs(q));
      }
      const snapshots = await Promise.all(promises);
      nearbyUsersList.innerHTML = '';
      const nearbyUsers = [];
      for (const snap of snapshots) {
        for (const doc of snap.docs) {
          const data = doc.data();
          if (data.beaconOn && data.location) {
            const distance = geofire.distanceBetween([data.location.latitude, data.location.longitude], userPosition) * 1000;
            if (distance <= radiusInM && doc.id !== userId) {
              nearbyUsers.push({ id: doc.id, name: data.name, distance });
            }
          }
        }
      }
      nearbyUsers.forEach(user => {
        const li = document.createElement('li');
        li.textContent = `${user.name} (${Math.round(user.distance)}m)`;
        const msgButton = document.createElement('button');
        msgButton.textContent = 'Message';
        msgButton.onclick = () => {
          selectedRecipientId = user.id;
          messageList.innerHTML = `<h3>Messages with ${user.name}</h3>`;
          listenForMessages();
        };
        li.appendChild(msgButton);
        nearbyUsersList.appendChild(li);
      });
      updateBeep(nearbyUsers.length);
      currentNearbyUserCount = nearbyUsers.length;
    }

    sendMessageButton.addEventListener('click', async () => {
      if (selectedRecipientId && messageInput.value.trim()) {
        const message = {
          senderId: userId,
          recipientId: selectedRecipientId,
          content: messageInput.value.trim(),
          timestamp: new Date()
        };
        await setDoc(doc(collection(db, 'users', selectedRecipientId, 'messages')), message);
        messageInput.value = '';
      }
    });

    function listenForMessages() {
      if (!selectedRecipientId) return;
      onSnapshot(collection(db, 'users', userId, 'messages'), snapshot => {
        messageList.innerHTML = `<h3>Messages with ${selectedRecipientId.substring(0, 5)}</h3>`;
        snapshot.forEach(doc => {
          const msg = doc.data();
          const p = document.createElement('p');
          p.textContent = `${msg.senderId === userId ? 'You' : 'They'}: ${msg.content}`;
          messageList.appendChild(p);
        });
      });
    }

    function startBeep() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (!oscillator) {
        oscillator = audioContext.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.connect(audioContext.destination);
        oscillator.start();
      }
    }

    function stopBeep() {
      if (oscillator) {
        oscillator.stop();
        oscillator.disconnect();
        oscillator = null;
      }
    }

    function updateBeep(nearbyUserCount) {
      if (!beaconOn || !audioContext) {
        stopBeep();
        return;
      }
      if (nearbyUserCount > 0) {
        if (!oscillator) {
          startBeep();
        }
      } else {
        stopBeep();
      }
    }

    // Keep user list updated and trigger fetchNearbyUsers for beep logic
    onSnapshot(collection(db, 'users'), snapshot => {
      snapshot.forEach(doc => {
        const data = doc.data();
        const id = doc.id;
        if (id === userId) return;
        if (data.beaconOn && data.location) {
          const latlng = [data.location.latitude, data.location.longitude];
          if (otherUsers[id]) {
            otherUsers[id].marker.setLatLng(latlng);
            otherUsers[id].location = data.location;
            otherUsers[id].beaconOn = data.beaconOn;
          } else {
            otherUsers[id] = {
              marker: L.circleMarker(latlng, { color: 'blue', radius: 8 }).addTo(map),
              location: data.location,
              beaconOn: data.beaconOn
            };
          }
        } else if (otherUsers[id]) {
          map.removeLayer(otherUsers[id].marker);
          delete otherUsers[id];
        }
      });
      if (beaconOn) {
        fetchNearbyUsers();
      } else {
        updateBeep(0);
      }
    });

    // ðŸ”’ Clean up on unload to prevent duplicates
    window.addEventListener('beforeunload', async () => {
      if (userId) {
        try {
          await setDoc(doc(db, 'users', userId), { beaconOn: false }, { merge: true });
        } catch (e) {
          console.error('Cleanup error:', e);
        }
      }
    });
  </script>
</body>
</html>
