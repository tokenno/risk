<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nearby Users App</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #1a1a1a;
      color: #e0e0e0;
    }
    .container {
      max-width: 700px;
      margin: 0 auto;
      background: #2c2c2c;
      border-radius: 6px;
      padding: 15px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }
    .section {
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
    }
    h3 {
      margin: 0 0 8px;
      font-size: 1.1em;
      color: #fff;
    }
    button {
      padding: 6px 12px;
      background: #28a745;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85em;
      transition: background 0.2s;
      margin-right: 5px;
    }
    button:hover {
      background: #218838;
    }
    .error {
      color: #ff4d4d;
      font-size: 0.8em;
      margin-top: 8px;
    }
    .user-list div {
      padding: 8px;
      border-bottom: 1px solid #444;
      cursor: pointer;
      transition: background 0.2s;
      color: #e0e0e0;
    }
    .user-list div:hover {
      background: #3a3a3a;
    }
    .user-list div:last-child {
      border-bottom: none;
    }
    .chat-messages {
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 8px;
      background: #2a2a2a;
      margin-bottom: 8px;
    }
    .chat-messages div {
      margin-bottom: 6px;
      font-size: 0.85em;
    }
    .chat-messages strong {
      color: #28a745;
    }
    .chat-messages span {
      color: #888;
      font-size: 0.75em;
      margin-left: 4px;
    }
    input {
      padding: 6px;
      width: calc(100% - 70px);
      border: 1px solid #555;
      border-radius: 4px;
      margin-right: 8px;
      font-size: 0.85em;
      background: transparent;
      color: #e0e0e0;
    }
    input:focus {
      outline: none;
      border-color: #28a745;
      box-shadow: 0 0 4px rgba(40, 167, 69, 0.5);
    }
    select {
      padding: 6px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2a2a2a;
      color: #e0e0e0;
      font-size: 0.85em;
      margin-bottom: 8px;
    }
    .debug {
      font-size: 0.8em;
      color: #aaa;
      background: #2a2a2a;
      font-family: 'Courier New', monospace;
    }
    .debug div {
      margin-bottom: 4px;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .user-info span {
      font-size: 1.4em;
      font-weight: bold;
      color: #28a745;
    }
    #map {
      height: 200px;
      border: 1px solid #555;
      border-radius: 4px;
      margin-top: 8px;
    }
    @media (max-width: 600px) {
      .container {
        padding: 8px;
      }
      button, input, select {
        width: 100%;
        margin: 4px 0;
      }
      .section {
        padding: 8px;
      }
      #map {
        height: 150px;
      }
    }
  </style>
</head>
<body>
  <div id="app" class="container">
    <div class="section">
      <div v-if="currentUser" class="user-info">
        <span>{{ currentUser.name.charAt(0).toUpperCase() }}</span>
        <div>
          <div>{{ currentUser.name }}</div>
          <div v-if="currentUser.gender">Gender: {{ currentUser.gender }}</div>
          <div v-if="status === 'ONLINE'">Currently online</div>
          <div v-else>Currently offline</div>
        </div>
      </div>
    </div>

    <div class="section">
      <button @click="toggleStatus">{{ status === 'ONLINE' ? 'Go Offline' : 'Go Online' }}</button>
      <button @click="changeName">Change Name</button>
      <button @click="setGender">Set Gender</button>
      <button @click="toggleBeep">{{ beepEnabled ? 'Disable Beep' : 'Enable Beep' }}</button>
    </div>

    <div class="section">
      <h3>Your Location</h3>
      <div v-if="userLocation.latitude && userLocation.longitude">
        <div>Latitude: {{ userLocation.latitude.toFixed(6) }}</div>
        <div>Longitude: {{ userLocation.longitude.toFixed(6) }}</div>
        <div id="map"></div>
      </div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
      <div v-if="!userLocation.latitude && !errorMessage">Acquiring your location...</div>
    </div>

    <div class="section">
      <h3>Nearby Users ({{ nearbyUsers.length }})</h3>
      <select multiple v-model="genderFilter" @change="fetchNearbyUsers">
        <option value="All">All Genders</option>
        <option value="Male">Male</option>
        <option value="Female">Female</option>
        <option value="Non-binary">Non-binary</option>
        <option value="Trans">Trans</option>
        <option value="Gay">Gay</option>
        <option value="Lesbian">Lesbian</option>
      </select>
      <div v-if="loadingNearbyUsers">Loading nearby users...</div>
      <div v-else-if="!loadingNearbyUsers && nearbyUsers.length === 0">No users nearby</div>
      <div v-if="userError" class="error">{{ userError.message }}</div>
      <div v-for="user in nearbyUsers" :key="user.id" class="user-list" @click="selectUser(user)">
        <div>{{ user.name }} ({{ user.gender || 'Not set' }})</div>
        <div v-if="user.distance < 1000">{{ user.distance }}m away</div>
        <div v-else>{{ (user.distance/1000).toFixed(2) }}km away</div>
        <div>{{ formatRelativeTime(user?.lastSeen?.toDate()) }}</div>
      </div>
    </div>

    <div class="section" v-if="selectedUser?.name">
      <h3>Chat with {{ selectedUser?.name }}</h3>
      <div class="chat-messages">
        <div v-if="messages.length === 0">Start a conversation with {{ selectedUser?.name }}</div>
        <div v-for="message in messages" :key="message?.id">
          <strong>{{ message.sender.name }}:</strong> {{ message?.text }} <span>{{ formatTime(message?.timestamp?.toDate()) }}</span>
        </div>
      </div>
      <input v-model="messageValue" placeholder="Type a message...">
      <button @click="sendMessage">Send</button>
    </div>

    <div class="section debug">
      <h3>Debug Information</h3>
      <div>Firebase: {{ firebaseInitialized ? 'Connected' : 'Disconnected' }}</div>
      <div>User ID: {{ currentUser?.id || 'Not set' }}</div>
      <div>Session ID: {{ sessionId || 'Not set' }}</div>
      <div>Location: {{ userLocation.latitude && userLocation.longitude ? 'Valid' : 'Invalid' }}</div>
      <div>Last Update: {{ lastLocationUpdate?.timestamp ? new Date(lastLocationUpdate?.timestamp).toLocaleTimeString() : 'Never' }}</div>
      <div>Beep Alert: {{ beepEnabled ? 'Enabled' : 'Disabled' }}</div>
      <div>Gender Filter: {{ genderFilter.length ? genderFilter.join(', ') : 'None' }}</div>
      <button @click="forceRefresh">Force Refresh</button>
      <button @click="showDBStructure">Show DB Structure</button>
    </div>
  </div>

  <script>
    // Import Vue
    const { createApp, ref, onMounted, watch } = Vue;

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDC6w15EQdfuBTZHlpvoxmaL5ISEgbFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.firebasestorage.app",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    // Initialize Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    firebase.analytics();

    createApp({
      setup() {
        const user = ref(null); // Deprecated, using currentUser
        const status = ref('OFFLINE');
        const currentUser = ref(null);
        const userLocation = ref({ latitude: null, longitude: null });
        const lastLocationUpdate = ref(null);
        const nearbyUsers = ref([]);
        const loadingNearbyUsers = ref(false);
        const errorMessage = ref('');
        const userError = ref('');
        const selectedUser = ref(null);
        const messages = ref([]);
        const messageValue = ref('');
        const firebaseInitialized = ref(true);
        const beepEnabled = ref(false);
        const genderFilter = ref(['All']);
        const sessionId = ref(null);
        let map = null;
        let userMarker = null;
        let nearbyMarkers = [];
        let unsubscribeMessages = null;
        let beepInterval = null;
        let audioContext = null;
        let locationRequestPending = false;

        // Gender options
        const genderOptions = ['Male', 'Female', 'Non-binary', 'Trans', 'Gay', 'Lesbian'];

        // Custom marker icons
        const redIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34]
        });
        const markerColors = ['blue', 'green', 'purple', 'orange', 'yellow'];

        // Generate unique session ID
        function generateSessionId() {
          return Math.random().toString(36).substr(2, 9);
        }

        // Initialize audio context
        function initAudioContext() {
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
        }

        // Play beep sound
        function playBeep() {
          if (!audioContext) initAudioContext();
          const oscillator = audioContext.createOscillator();
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
          oscillator.connect(audioContext.destination);
          oscillator.start();
          oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Toggle beep alert
        function toggleBeep() {
          initAudioContext();
          beepEnabled.value = !beepEnabled.value;
          if (!beepEnabled.value && beepInterval) {
            clearInterval(beepInterval);
            beepInterval = null;
          }
        }

        // Set user gender
        function setGender() {
          const gender = prompt('Select your gender:\n' + genderOptions.join(', '), currentUser.value.gender || '');
          if (gender && genderOptions.includes(gender)) {
            currentUser.value.gender = gender;
            updateUserLocation();
          } else if (gender !== null) {
            alert('Invalid gender. Please choose from: ' + genderOptions.join(', '));
          }
        }

        // Authentication state
        onMounted(() => {
          sessionId.value = generateSessionId();
          auth.onAuthStateChanged((userData) => {
            if (userData) {
              currentUser.value = { id: userData.uid, name: userData.displayName || 'Anonymous', gender: null };
              db.collection('users').doc(userData.uid).get().then(doc => {
                if (doc.exists && doc.data().gender) {
                  currentUser.value.gender = doc.data().gender;
                }
              }).catch(error => {
                console.error('Error fetching user data:', error);
              });
              getUserLocation();
            } else {
              errorMessage.value = 'Please sign in';
              signIn();
            }
          });
        });

        // Initialize map
        watch(userLocation, (newLocation) => {
          if (newLocation?.latitude && newLocation?.longitude && !map) {
            try {
              map = L.map('map').setView([newLocation.latitude, newLocation.longitude], 13);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 18
              }).addTo(map);
              userMarker = L.marker([newLocation.latitude, newLocation.longitude], { icon: redIcon }).addTo(map).bindPopup('You are here');
            } catch (error) {
              console.error('Map initialization failed:', error);
              errorMessage.value = 'Failed to initialize map';
            }
          }
          if (map && newLocation?.latitude && newLocation?.longitude) {
            map.setView([newLocation.latitude, newLocation.longitude], 13);
            if (userMarker) {
              userMarker.setLatLng([newLocation.latitude, newLocation.longitude]);
            }
          }
        });

        // Update nearby users on map
        watch(nearbyUsers, (newUsers) => {
          if (map) {
            nearbyMarkers.forEach(marker => map.removeLayer(marker));
            nearbyMarkers = [];
            newUsers.forEach((user, index) => {
              const colorIndex = index % markerColors.length;
              const icon = L.icon({
                iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${markerColors[colorIndex]}.png`,
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34]
              });
              const marker = L.marker([user.latitude, user.longitude], { icon })
                .addTo(map)
                .bindPopup(`${user.name} (${user.gender || 'Not set'}, ${user.distance < 1000 ? user.distance + 'm' : (user.distance/1000).toFixed(2) + 'km'} away)`);
              nearbyMarkers.push(marker);
            });
          }
        });

        // Sign in with Google
        async function signIn() {
          const provider = new firebase.auth.GoogleAuthProvider();
          try {
            await auth.signInWithPopup(provider);
          } catch (error) {
            errorMessage.value = 'Sign-in failed: ' + error.message;
            console.error('Sign-in error:', error);
          }
        }

        // Get user location
        function getUserLocation() {
          if (!navigator.geolocation) {
            errorMessage.value = 'Geolocation not supported by your browser';
            return;
          }
          if (locationRequestPending) return;
          locationRequestPending = true;
          navigator.geolocation.getCurrentPosition(
            (position) => {
              userLocation.value = { latitude: position.coords.latitude, longitude: position.coords.longitude };
              lastLocationUpdate.value = { timestamp: new Date() };
              updateUserLocation();
              if (status.value === 'ONLINE') fetchNearbyUsers();
              locationRequestPending = false;
            },
            (error) => {
              locationRequestPending = false;
              if (error.code === error.PERMISSION_DENIED) {
                errorMessage.value = 'Location access denied. Please enable location services.';
              } else if (error.message.includes('permissions policy')) {
                errorMessage.value = 'Geolocation disabled by permissions policy. Use HTTPS.';
              } else {
                errorMessage.value = 'Failed to acquire location: ' + error.message;
              }
              console.error('Geolocation error:', error);
            }
          );
        }

        // Update user location and status
        async function updateUserLocation() {
          if (currentUser.value?.id && userLocation.value?.latitude && userLocation.value?.longitude) {
            try {
              await db.collection('users').doc(currentUser.value.id).set({
                name: currentUser.value.name,
                status: status.value,
                latitude: userLocation.value.latitude,
                longitude: userLocation.value.longitude,
                gender: currentUser.value.gender || null,
                sessionId: sessionId.value,
                lastSeen: firebase.firestore.Timestamp.now()
              }, { merge: true });
            } catch (error) {
              errorMessage.value = 'Failed to update location: ' + error.message;
              console.error('Update location error:', error);
            }
          }
        }

        // Toggle online/offline status
        async function toggleStatus() {
          console.log('Toggling status to:', status.value === 'ONLINE' ? 'OFFLINE' : 'ONLINE');
          status.value = status.value === 'ONLINE' ? 'OFFLINE' : 'ONLINE';
          try {
            await updateUserLocation();
            if (status.value === 'ONLINE') {
              fetchNearbyUsers();
            } else {
              nearbyUsers.value = [];
              if (beepInterval) {
                clearInterval(beepInterval);
                beepInterval = null;
              }
            }
          } catch (error) {
            errorMessage.value = 'Failed to toggle status: ' + error.message;
            console.error('Toggle status error:', error);
          }
        }

        // Change user name
        async function changeName() {
          const newName = prompt('Enter new name:', currentUser.value.name);
          if (newName) {
            currentUser.value.name = newName;
            await updateUserLocation();
          }
        }

        // Select user for chat
        function selectUser(user) {
          selectedUser.value = user;
          messages.value = [];
          if (unsubscribeMessages) unsubscribeMessages();
          if (user?.id && currentUser.value?.id) {
            const q = db.collection('messages').where('participants', 'array-contains', currentUser.value.id);
            unsubscribeMessages = q.onSnapshot((snapshot) => {
              messages.value = snapshot.docs
                .map(doc => ({ id: doc.id, sender: doc.data().sender, text: doc.data().text, timestamp: doc.data().timestamp, participants: doc.data().participants }))
                .filter(msg => msg.participants.includes(user.id))
                .sort((a, b) => a.timestamp.toDate() - b.timestamp.toDate());
            }, (error) => {
              errorMessage.value = 'Failed to load messages: ' + error.message;
              console.error('Messages snapshot error:', error);
            });
          }
        }

        // Calculate distance
        function calculateDistance(coord1, coord2) {
          if (!coord1?.latitude || !coord1?.longitude || !coord2?.latitude || !coord2?.longitude) return 0;
          const R = 6371e3;
          const lat1 = coord1.latitude * Math.PI / 180;
          const lat2 = coord2.latitude * Math.PI / 180;
          const deltaLat = (coord2.latitude - coord1.latitude) * Math.PI / 180;
          const deltaLon = (coord2.longitude - coord1.longitude) * Math.PI / 180;
          const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        // Fetch nearby users
        function fetchNearbyUsers() {
          if (!userLocation.value?.latitude || !userLocation.value?.longitude) {
            errorMessage.value = 'Location not available';
            return;
          }
          loadingNearbyUsers.value = true;
          let q = db.collection('users').where('status', '==', 'ONLINE');
          if (!genderFilter.value.includes('All') && genderFilter.value.length > 0) {
            q = q.where('gender', 'in', genderFilter.value.slice(0, 10));
          }
          try {
            q.onSnapshot((snapshot) => {
              nearbyUsers.value = snapshot.docs
                .filter(doc => doc.id !== currentUser.value.id)
                .map(doc => {
                  const data = doc.data();
                  const distance = calculateDistance(userLocation.value, { latitude: data.latitude, longitude: data.longitude });
                  return { 
                    id: doc.id, 
                    name: data.name, 
                    distance, 
                    lastSeen: data.lastSeen,
                    latitude: data.latitude,
                    longitude: data.longitude,
                    gender: data.gender
                  };
                })
                .filter(user => user.distance < 10000);
              
              // Beep alert logic
              if (beepEnabled.value) {
                if (beepInterval) clearInterval(beepInterval);
                const closestUser = nearbyUsers.value.reduce((closest, user) => 
                  user.distance < closest.distance ? user : closest, 
                  { distance: Infinity }
                );
                if (closestUser.distance <= 1000) {
                  let interval;
                  if (closestUser.distance < 100) interval = 500;
                  else if (closestUser.distance < 500) interval = 1000;
                  else interval = 2000;
                  beepInterval = setInterval(playBeep, interval);
                } else {
                  beepInterval = null;
                }
              }
              
              loadingNearbyUsers.value = false;
            }, (error) => {
              errorMessage.value = 'Failed to load nearby users: ' + error.message;
              console.error('Nearby users snapshot error:', error);
              loadingNearbyUsers.value = false;
            });
          } catch (error) {
            errorMessage.value = 'Error fetching nearby users: ' + error.message;
            console.error('Fetch nearby users error:', error);
            loadingNearbyUsers.value = false;
          }
        }

        // Send message
        async function sendMessage() {
          if (!messageValue.value || !selectedUser.value?.id) return;
          try {
            await db.collection('messages').add({
              sender: currentUser.value,
              senderId: currentUser.value.id,
              text: messageValue.value,
              timestamp: firebase.firestore.Timestamp.now(),
              recipientId: selectedUser.value.id,
              participants: [currentUser.value.id, selectedUser.value.id]
            });
            messageValue.value = '';
          } catch (error) {
            errorMessage.value = 'Failed to send message: ' + error.message;
            console.error('Send message error:', error);
          }
        }

        // Format relative time
        function formatRelativeTime(timestamp) {
          if (!timestamp) return 'Unknown time';
          const now = new Date();
          const date = timestamp.toDate();
          const diff = (now - date) / 1000;
          if (diff < 60) return `${Math.floor(diff)} seconds ago`;
          if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
          return `${Math.floor(diff / 3600)} hours ago`;
        }

        // Format message time
        function formatTime(timestamp) {
          if (!timestamp) return 'Unknown time';
          return timestamp.toDate().toLocaleTimeString();
        }

        // Force refresh
        function forceRefresh() {
          getUserLocation();
          if (status.value === 'ONLINE') fetchNearbyUsers();
        }

        // Show DB structure
        function showDBStructure() {
          alert('Firestore Structure:\n' +
                '- Collection: users\n' +
                '  - Document: {userId}\n' +
                '    - name: string\n' +
                '    - status: "ONLINE" | "OFFLINE"\n' +
                '    - latitude: number\n' +
                '    - longitude: number\n' +
                '    - gender: string (Male, Female, Non-binary, Trans, Gay, Lesbian, or null)\n' +
                '    - sessionId: string\n' +
                '    - lastSeen: timestamp\n' +
                '- Collection: messages\n' +
                '  - Document: {messageId}\n' +
                '    - sender: object\n' +
                '    - senderId: string\n' +
                '    - text: string\n' +
                '    - timestamp: timestamp\n' +
                '    - recipientId: string\n' +
                '    - participants: array<string>');
        }

        return {
          user,
          status,
          currentUser,
          userLocation,
          lastLocationUpdate,
          nearbyUsers,
          loadingNearbyUsers,
          errorMessage,
          userError,
          selectedUser,
          messages,
          messageValue,
          firebaseInitialized,
          beepEnabled,
          genderFilter,
          sessionId,
          toggleStatus,
          changeName,
          setGender,
          selectUser,
          sendMessage,
          toggleBeep,
          formatRelativeTime,
          formatTime,
          forceRefresh,
          showDBStructure
        };
      }
    }).mount('#app')
  </script>
</body>
</html>