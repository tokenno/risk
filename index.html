<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Live Risk Map with Real-time Tracking</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
        crossorigin=""/>
  <!-- Vue.js Production Build -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- Firebase SDKs -->
  <script type="module">
    // Firebase v9 Modular Imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, set, onValue, off, push } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDC6w15EQdfuBTZHlpvoxmaL5ISEgbFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.appspot.com",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    // Make available to Vue app
    window.firebase = {
      db,
      ref,
      set,
      onValue,
      off,
      push,
      auth,
      signInAnonymously
    };
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      max-width: 1000px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }
    #map {
      height: 500px;
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .map-container {
      grid-column: 1;
    }
    .panel {
      grid-column: 2;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .user-list, .messaging {
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 8px;
      background: #f9f9f9;
      max-height: 300px;
      overflow-y: auto;
    }
    .user-card {
      padding: 10px;
      margin: 5px 0;
      background: white;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
    }
    .user-card:hover {
      background: #eef;
    }
    .user-card.active {
      background: #007bff;
      color: white;
    }
    .user-card.proximity-alert {
      animation: pulse 1s infinite;
      background: #ff4444;
      color: white;
    }
    .message {
      margin: 8px 0;
      padding: 8px;
      background: white;
      border-radius: 4px;
    }
    .message-input {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    input {
      flex-grow: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    button {
      padding: 8px 15px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #0056b3;
    }
    .debug-button {
      background: #ff5722;
    }
    .debug-button:hover {
      background: #e64a19;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    .status-badge {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 5px;
    }
    .online {
      background: #28a745;
    }
    .offline {
      background: #dc3545;
    }
    .debug-info {
      color: #ff5722;
      font-size: 0.9em;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="map-container">
      <div id="map"></div>
    </div>
    
    <div class="panel">
      <div class="status-container">
        <h2>{{ user }} <span class="status-badge" :class="status.toLowerCase()"></span></h2>
        <div>
          <button @click="toggleOnlineStatus">
            {{ status === 'ONLINE' ? 'Go Offline' : 'Go Online' }}
          </button>
          <button @click="setName">Change Name</button>
        </div>
        <p v-if="userLocation">
          Location: {{ userLocation[0].toFixed(4) }}, {{ userLocation[1].toFixed(4) }}
        </p>
        <p v-else>Acquiring location...</p>
        
        <!-- Debug Controls -->
        <button @click="toggleDebugMode" class="debug-button" style="margin-top: 10px;">
          {{ debugMode ? 'Disable Debug Mode' : 'Enable Debug Mode' }}
        </button>
        <button @click="forceLocationUpdate" class="debug-button" v-if="debugMode" style="margin-top: 10px;">
          Simulate Movement
        </button>
        <p class="debug-info" v-if="debugMode">Debug mode active - showing test users</p>
      </div>

      <div class="user-list">
        <h3>Nearby Users ({{ nearbyUsers.length }})</h3>
        <div v-if="loadingNearby">Loading nearby users...</div>
        <div v-else-if="nearbyUsers.length === 0">No users nearby</div>
        <div v-else>
          <div v-for="user in nearbyUsers" 
               :key="user.id"
               class="user-card"
               :class="{ 
                 active: selectedUser?.id === user.id,
                 'proximity-alert': user.distance < 20 
               }"
               @click="selectUser(user)">
            <span>{{ user.name }}</span>
            <span>{{ user.distance }}m</span>
          </div>
        </div>
      </div>

      <div class="messaging" v-if="selectedUser">
        <h3>Chat with {{ selectedUser.name }}</h3>
        <div class="message-box">
          <div v-for="msg in messages" :key="msg.id" class="message">
            <strong>{{ msg.sender }}:</strong> {{ msg.text }}
            <small>{{ formatTime(msg.timestamp) }}</small>
          </div>
        </div>
        <div class="message-input">
          <input v-model="newMessage" 
                 @keyup.enter="sendMessage" 
                 placeholder="Type a message...">
          <button @click="sendMessage">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>
  
  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          status: 'OFFLINE',
          user: localStorage.getItem('username') || 'Anonymous',
          userLocation: null,
          map: null,
          userMarker: null,
          nearbyUsers: [],
          loadingNearby: true,
          selectedUser: null,
          messages: [],
          newMessage: '',
          currentUserId: null,
          proximityAlert: null,
          userMarkers: {},
          debounceTimer: null,
          lastLocationUpdate: 0,
          messagesListener: null,
          locationWatchId: null,
          debugMode: false,
          debugInterval: null,
          debugUsers: [
            { id: 'debug1', name: 'Test User 1', lat: 51.505, lng: -0.09 },
            { id: 'debug2', name: 'Test User 2', lat: 51.51, lng: -0.1 }
          ]
        };
      },
      async mounted() {
        await this.waitForFirebase();
        this.initMap();
        this.startLocationTracking();
        
        window.addEventListener('beforeunload', () => {
          if (this.currentUserId && this.status === 'ONLINE') {
            firebase.set(firebase.ref(firebase.db, `users/${this.currentUserId}`), null);
          }
        });

        if (window.location.hostname === "localhost") {
          window.app = this;
        }
      },
      methods: {
        waitForFirebase() {
          return new Promise((resolve) => {
            const check = () => {
              if (window.firebase) {
                resolve();
              } else {
                setTimeout(check, 100);
              }
            };
            check();
          });
        },
        
        initMap() {
          this.map = L.map('map').setView([51.505, -0.09], 13);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
          }).addTo(this.map);
        },

        startLocationTracking() {
          if (!navigator.geolocation) {
            console.error("Geolocation not supported");
            return;
          }

          const options = {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          };

          this.locationWatchId = navigator.geolocation.watchPosition(
            position => this.handleNewPosition(position),
            error => this.handleLocationError(error),
            options
          );
        },

        handleNewPosition(position) {
          const { latitude, longitude } = position.coords;
          this.userLocation = [latitude, longitude];
          
          if (this.debounceTimer) clearTimeout(this.debounceTimer);
          
          this.debounceTimer = setTimeout(() => {
            if (this.status === 'ONLINE') {
              this.updateUserLocation();
            }
            this.updateMapMarker();
          }, 1000);
        },

        updateMapMarker() {
          if (!this.map) return;
          
          if (!this.userMarker) {
            this.userMarker = L.marker(this.userLocation, {
              icon: L.divIcon({
                html: `<div style="background:#007bff;color:white;border-radius:50%;width:30px;height:30px;display:flex;align-items:center;justify-content:center;border:2px solid white">${this.user.charAt(0)}</div>`,
                className: '',
                iconSize: [30, 30]
              })
            })
            .addTo(this.map)
            .bindPopup(`<b>${this.user}</b><br>You are here`)
            .openPopup();
          } else {
            this.userMarker.setLatLng(this.userLocation);
          }
          
          this.map.setView(this.userLocation, 15);
        },

        async toggleOnlineStatus() {
          if (this.status === 'OFFLINE') {
            try {
              const userCredential = await firebase.signInAnonymously(firebase.auth);
              this.currentUserId = userCredential.user.uid;
              this.status = 'ONLINE';
              this.updateUserLocation();
              this.listenForNearbyUsers();
            } catch (error) {
              console.error("Login failed:", error);
            }
          } else {
            const userRef = firebase.ref(firebase.db, `users/${this.currentUserId}`);
            userRef.onDisconnect().cancel();
            await firebase.set(userRef, null);
            firebase.off(firebase.ref(firebase.db, 'users'));
            this.status = 'OFFLINE';
            this.clearUserMarkers();
          }
        },

        async updateUserLocation() {
          if (!this.userLocation || !this.currentUserId) return;
          
          const userRef = firebase.ref(firebase.db, `users/${this.currentUserId}`);
          await firebase.set(userRef, {
            lat: this.userLocation[0],
            lng: this.userLocation[1],
            name: this.user,
            lastOnline: Date.now()
          });

          userRef.onDisconnect().remove();
        },

        listenForNearbyUsers() {
          const usersRef = firebase.ref(firebase.db, 'users');
          
          firebase.onValue(usersRef, (snapshot) => {
            const allUsers = snapshot.val() || {};
            this.processNearbyUsers(allUsers);
          }, (error) => {
            console.error("Firebase read failed:", error);
            this.loadingNearby = false;
          });
        },

        processNearbyUsers(allUsers) {
          this.clearUserMarkers();
          
          const usersToProcess = { ...allUsers };
          if (this.debugMode) {
            this.debugUsers.forEach(user => {
              usersToProcess[user.id] = {
                lat: user.lat,
                lng: user.lng,
                name: user.name,
                lastOnline: Date.now()
              };
            });
          }
          
          this.nearbyUsers = Object.entries(usersToProcess)
            .filter(([id, user]) => {
              return id !== this.currentUserId && 
                     Date.now() - user.lastOnline < 300000;
            })
            .map(([id, user]) => {
              const distance = this.calculateDistance(
                this.userLocation,
                [user.lat, user.lng]
              );
              
              this.updateUserMarker(id, user, distance);
              
              return {
                id,
                name: user.name || 'Anonymous',
                distance: Math.round(distance),
                position: [user.lat, user.lng],
                lastSeen: user.lastOnline
              };
            })
            .filter(user => user.distance < 1000)
            .sort((a, b) => a.distance - b.distance);
            
          this.loadingNearby = false;
          this.checkProximityAlerts();
        },

        updateUserMarker(userId, user, distance) {
          if (!this.userMarkers[userId]) {
            this.userMarkers[userId] = L.marker([user.lat, user.lng], {
              icon: L.divIcon({
                html: `<div style="background:#28a745;color:white;border-radius:50%;width:24px;height:24px;display:flex;align-items:center;justify-content:center;border:2px solid white">${user.name?.charAt(0) || '?'}</div>`,
                className: '',
                iconSize: [24, 24]
              })
            })
            .addTo(this.map)
            .bindPopup(`<b>${user.name || 'User'}</b><br>${distance}m away`);
          } else {
            this.userMarkers[userId].setLatLng([user.lat, user.lng]);
            this.userMarkers[userId].setPopupContent(`<b>${user.name || 'User'}</b><br>${distance}m away`);
          }
        },

        clearUserMarkers() {
          Object.values(this.userMarkers).forEach(marker => marker.remove());
          this.userMarkers = {};
        },

        calculateDistance(pos1, pos2) {
          if (!pos1 || !pos2) return Infinity;
          
          const [lat1, lon1] = pos1;
          const [lat2, lon2] = pos2;
          const R = 6371e3;
          const φ1 = lat1 * Math.PI/180;
          const φ2 = lat2 * Math.PI/180;
          const Δφ = (lat2-lat1) * Math.PI/180;
          const Δλ = (lon2-lon1) * Math.PI/180;

          const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                   Math.cos(φ1) * Math.cos(φ2) *
                   Math.sin(Δλ/2) * Math.sin(Δλ/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

          return R * c;
        },

        checkProximityAlerts() {
          if (this.proximityAlert) {
            clearInterval(this.proximityAlert);
            this.proximityAlert = null;
          }

          const closeUsers = this.nearbyUsers.filter(u => u.distance < 20);
          if (closeUsers.length === 0) return;

          const closestDistance = Math.min(...closeUsers.map(u => u.distance));
          const audio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3');
          const speedFactor = 1 + (20 - closestDistance) / 5;
          
          this.proximityAlert = setInterval(() => {
            audio.playbackRate = speedFactor;
            audio.play().catch(e => console.log("Audio blocked:", e));
          }, 1000 / speedFactor);
        },

        setName() {
          const newName = prompt('Enter your name:', this.user);
          if (newName !== null) {
            this.user = newName || 'Anonymous';
            localStorage.setItem('username', this.user);
            if (this.userMarker) {
              this.userMarker.setPopupContent(`<b>${this.user}</b><br>You are here`);
            }
            if (this.status === 'ONLINE') {
              this.updateUserLocation();
            }
          }
        },

        toggleDebugMode() {
          this.debugMode = !this.debugMode;
          if (this.debugMode) {
            this.addDebugUsers();
          } else {
            this.removeDebugUsers();
          }
        },

        addDebugUsers() {
          this.debugUsers.forEach(user => {
            firebase.set(firebase.ref(firebase.db, `users/${user.id}`), {
              lat: user.lat,
              lng: user.lng,
              name: user.name,
              lastOnline: Date.now()
            });
          });
        },

        removeDebugUsers() {
          this.debugUsers.forEach(user => {
            firebase.set(firebase.ref(firebase.db, `users/${user.id}`), null);
          });
        },

        forceLocationUpdate() {
          if (!this.debugMode) return;
          
          this.debugUsers.forEach(user => {
            user.lat += (Math.random() - 0.5) * 0.001;
            user.lng += (Math.random() - 0.5) * 0.001;
            
            firebase.set(firebase.ref(firebase.db, `users/${user.id}`), {
              lat: user.lat,
              lng: user.lng,
              name: user.name,
              lastOnline: Date.now()
            });
          });
          
          if (this.debugInterval) clearInterval(this.debugInterval);
          this.debugInterval = setInterval(this.forceLocationUpdate, 3000);
        },

        selectUser(user) {
          this.selectedUser = user;
          this.loadMessages();
        },

        loadMessages() {
          if (!this.selectedUser) return;
          
          const chatId = [this.currentUserId, this.selectedUser.id].sort().join('_');
          const messagesRef = firebase.ref(firebase.db, `messages/${chatId}`);
          
          if (this.messagesListener) {
            firebase.off(this.messagesListener);
          }
          
          this.messagesListener = firebase.onValue(messagesRef, (snapshot) => {
            const messagesData = snapshot.val() || {};
            this.messages = Object.entries(messagesData)
              .map(([id, msg]) => ({ id, ...msg }))
              .sort((a, b) => a.timestamp - b.timestamp);
          });
        },

        sendMessage() {
          if (!this.newMessage.trim() || !this.selectedUser) return;
          
          const chatId = [this.currentUserId, this.selectedUser.id].sort().join('_');
          const messagesRef = firebase.ref(firebase.db, `messages/${chatId}`);
          
          firebase.push(messagesRef, {
            text: this.newMessage,
            sender: this.user,
            timestamp: Date.now()
          });
          
          this.newMessage = '';
        },

        formatTime(timestamp) {
          return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        },

        handleLocationError(error) {
          console.error("Geolocation error:", error);
          let message = "Location error: ";
          switch(error.code) {
            case error.PERMISSION_DENIED:
              message += "Permission denied. Please enable location access.";
              break;
            case error.POSITION_UNAVAILABLE:
              message += "Location unavailable.";
              break;
            case error.TIMEOUT:
              message += "Request timed out.";
              break;
            default:
              message += "Unknown error.";
          }
          alert(message);
        }
      },
      beforeUnmount() {
        if (this.locationWatchId) {
          navigator.geolocation.clearWatch(this.locationWatchId);
        }
        if (this.messagesListener) {
          firebase.off(this.messagesListener);
        }
        if (this.status === 'ONLINE') {
          const userRef = firebase.ref(firebase.db, `users/${this.currentUserId}`);
          userRef.onDisconnect().cancel();
          firebase.set(userRef, null);
        }
        if (this.debugInterval) {
          clearInterval(this.debugInterval);
        }
      }
    }).mount('#app');
  </script>
</body>
</html>