<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FCK DOT</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #1a1a1a;
      color: #e0e0e0;
    }
    .container {
      max-width: 700px;
      margin: 0 auto;
      background: #2c2c2c;
      border-radius: 6px;
      padding: 15px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }
    .section {
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
    }
    h3 {
      margin: 0 0 8px;
      font-size: 1.1em;
      color: #fff;
    }
    button {
      padding: 6px 12px;
      background: #28a745;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85em;
      transition: background 0.2s;
    }
    button:hover {
      background: #218838;
    }
    button.warning {
      background: #dc3545;
    }
    button.warning:hover {
      background: #c82333;
    }
    .error {
      color: #ff4d4d;
      font-size: 0.8em;
      margin-top: 8px;
    }
    .user-list div {
      padding: 8px;
      border-bottom: 1px solid #444;
      transition: background 0.2s;
      color: #e0e0e0;
    }
    .user-list div:last-child {
      border-bottom: none;
    }
    #map {
      height: 200px;
      width: 100%;
      border: 1px solid #555;
      border-radius: 4px;
      margin-top: 8px;
      background: #1a1a1a;
    }
    .map-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #888;
    }
    @media (max-width: 600px) {
      .container {
        padding: 8px;
      }
      button {
        width: 100%;
        margin: 4px 0;
      }
      .section {
        padding: 8px;
      }
      #map {
        height: 150px;
      }
    }
  </style>
</head>
<body>
  <div id="app" class="container">
    <div class="section">
      <div v-if="user" class="user-info">
        <span>{{ user.charAt(0).toUpperCase() }}</span>
        <div>
          <div>{{ user }}</div>
          <div v-if="status === 'ONLINE'">Currently online</div>
          <div v-else>Currently offline</div>
        </div>
      </div>
    </div>

    <div class="section">
      <button @click="toggleStatus">{{ status === 'ONLINE' ? 'Go Offline' : 'Go Online' }}</button>
      <button @click="changeName">Change Name</button>
      <button @click="toggleSound">{{ soundEnabled ? 'ðŸ”” Sound On' : 'ðŸ”• Sound Off' }}</button>
      <button class="warning" @click="clearStaleLocations" :disabled="clearingStaleLocations">
        {{ clearingStaleLocations ? 'Clearing...' : 'Clear Stale Locations' }}
      </button>
    </div>

    <div class="section">
      <h3>Your Location</h3>
      <div v-if="userLocation">
        <div>Latitude: {{ userLocation[0].toFixed(6) }}</div>
        <div>Longitude: {{ userLocation[1].toFixed(6) }}</div>
        <div id="map">
          <div v-if="!mapInitialized" class="map-loading">
            Loading map...
          </div>
        </div>
      </div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
      <div v-if="!userLocation && !errorMessage">Acquiring your location...</div>
    </div>

    <div class="section">
      <h3>Nearby Users ({{ nearbyUsers.length }})</h3>
      <div v-if="loadingNearby">Loading nearby users...</div>
      <div v-if="!loadingNearby && nearbyUsers.length === 0">No users nearby</div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
      <div v-for="user in nearbyUsers" :key="user.id" class="user-list">
        <div>{{ user.name }}</div>
        <div v-if="user.distance < 1000">{{ user.distance }}m away</div>
        <div v-else>{{ (user.distance/1000).toFixed(1) }}km away</div>
        <div>{{ formatRelativeTime(user.lastSeen) }}</div>
      </div>
    </div>

    <div class="section debug">
      <h3>Debug Information</h3>
      <div>Firebase: {{ firebaseInitialized ? 'Connected' : 'Disconnected' }}</div>
      <div>User ID: {{ currentUserId || 'Not set' }}</div>
      <div>Location: {{ userLocation ? 'Valid' : 'Invalid' }}</div>
      <div>Last Update: {{ lastLocationUpdate ? new Date(lastLocationUpdate).toLocaleTimeString() : 'Never' }}</div>
      <button @click="forceRefresh">Force Refresh</button>
    </div>
  </div>

  <script>
    // Import Vue
    const { createApp, ref, onMounted, watch, nextTick } = Vue;

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDC6w15EQdfuBTZHlpvoxmaL5ISEgbFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.appspot.com",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    // Initialize Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    firebase.analytics();

    createApp({
      setup() {
        const user = ref(null);
        const status = ref('OFFLINE');
        const currentUserId = ref(null);
        const userLocation = ref(null);
        const lastLocationUpdate = ref(null);
        const nearbyUsers = ref([]);
        const loadingNearby = ref(false);
        const errorMessage = ref('');
        const firebaseInitialized = ref(true);
        const soundEnabled = ref(true);
        const clearingStaleLocations = ref(false);
        const mapInitialized = ref(false);
        let map = null;
        let userMarker = null;
        let nearbyMarkers = [];
        let audioContext = null;
        let beepInterval = null;
        let closestDistance = Infinity;
        const colors = ['#3498db', '#2ecc71', '#e74c3c', '#9b59b6', '#f1c40f', '#1abc9c', '#e67e22'];

        // Initialize map
        function initMap(location) {
          try {
            // Wait for DOM to be ready
            nextTick(() => {
              if (!document.getElementById('map')) {
                throw new Error('Map container not found');
              }
              
              map = L.map('map').setView(location, 13);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 18
              }).addTo(map);
              
              userMarker = L.marker(location, {
                icon: L.divIcon({
                  html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
                  className: 'user-marker',
                  iconSize: [20, 20]
                })
              }).addTo(map).bindPopup(`<b>${user.value}</b><br>Your location`);
              
              mapInitialized.value = true;
            });
          } catch (error) {
            errorMessage.value = 'Map initialization failed: ' + error.message;
          }
        }

        // Update map location
        function updateMapLocation(location) {
          if (map) {
            map.setView(location, 13);
            if (userMarker) {
              userMarker.setLatLng(location);
            }
          } else {
            initMap(location);
          }
        }

        // Watch for location changes
        watch(userLocation, (newLocation) => {
          if (!newLocation) return;
          updateMapLocation(newLocation);
        }, { immediate: true });

        // Initialize audio context
        function initAudio() {
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
        }

        // Play beep sound
        function playBeep() {
          if (!audioContext || !soundEnabled.value) return;
          
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.value = 800;
          gainNode.gain.value = 0.1;
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.start();
          oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Update beep interval
        function updateBeepInterval() {
          if (beepInterval) clearInterval(beepInterval);
          
          if (closestDistance <= 20 && soundEnabled.value) {
            const bpm = 20 + (20 - Math.min(20, closestDistance)) * (130 / 20);
            const interval = 60000 / bpm;
            
            playBeep();
            beepInterval = setInterval(playBeep, interval);
          }
        }

        // Toggle sound
        function toggleSound() {
          soundEnabled.value = !soundEnabled.value;
          if (!soundEnabled.value && beepInterval) {
            clearInterval(beepInterval);
            beepInterval = null;
          }
        }

        // Clear stale locations
        async function clearStaleLocations() {
          if (clearingStaleLocations.value) return;
          
          clearingStaleLocations.value = true;
          const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
          
          try {
            const query = db.collection('users')
              .where('lastSeen', '<', fiveMinutesAgo);
            
            const snapshot = await query.get();
            const batch = db.batch();
            
            snapshot.forEach(doc => {
              batch.delete(doc.ref);
            });
            
            await batch.commit();
            errorMessage.value = `Cleared ${snapshot.size} stale locations`;
            fetchNearbyUsers();
          } catch (error) {
            errorMessage.value = 'Failed to clear stale locations: ' + error.message;
          } finally {
            clearingStaleLocations.value = false;
          }
        }

        // Authentication state
        onMounted(() => {
          initAudio();
          auth.onAuthStateChanged((userData) => {
            if (userData) {
              currentUserId.value = userData.uid;
              user.value = userData.displayName || 'Anonymous';
              getUserLocation();
            } else {
              errorMessage.value = 'Please sign in';
              signIn();
            }
          });
        });

        // Update nearby users on map
        watch(nearbyUsers, (newUsers) => {
          if (map) {
            nearbyMarkers.forEach(marker => map.removeLayer(marker));
            nearbyMarkers = newUsers.map((user, index) => {
              const color = colors[index % colors.length];
              return L.marker([user.latitude, user.longitude], {
                icon: L.divIcon({
                  html: `<div style="background-color: ${color}; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.name.charAt(0).toUpperCase()}</div>`,
                  className: 'user-marker',
                  iconSize: [20, 20]
                })
              }).addTo(map).bindPopup(`<b>${user.name}</b><br>${user.distance < 1000 ? user.distance + 'm' : (user.distance/1000).toFixed(1) + 'km'} away`);
            });
          }
          
          closestDistance = Infinity;
          newUsers.forEach(user => {
            if (user.distance < 20 && user.distance < closestDistance) {
              closestDistance = user.distance;
            }
          });
          
          updateBeepInterval();
        });

        // Sign in with Google
        async function signIn() {
          const provider = new firebase.auth.GoogleAuthProvider();
          try {
            await auth.signInWithPopup(provider);
          } catch (error) {
            errorMessage.value = 'Sign-in failed: ' + error.message;
          }
        }

        // Get user location
        function getUserLocation() {
          if (!navigator.geolocation) {
            errorMessage.value = 'Geolocation is not supported by your browser';
            return;
          }
          navigator.geolocation.getCurrentPosition(
            (position) => {
              userLocation.value = [position.coords.latitude, position.coords.longitude];
              lastLocationUpdate.value = Date.now();
              updateUserLocation();
              if (status.value === 'ONLINE') fetchNearbyUsers();
            },
            (error) => {
              if (error.code === error.PERMISSION_DENIED) {
                errorMessage.value = 'Location access denied. Please enable location services in your browser settings.';
              } else if (error.message.includes('permissions policy')) {
                errorMessage.value = 'Geolocation is disabled by browser permissions policy. Please serve this app over HTTPS or check browser settings.';
              } else {
                errorMessage.value = 'Failed to acquire location: ' + error.message;
              }
            }
          );
        }

        // Update user location in Firestore
        async function updateUserLocation() {
          if (currentUserId.value && userLocation.value) {
            try {
              await db.collection('users').doc(currentUserId.value).set({
                name: user.value,
                status: status.value,
                latitude: userLocation.value[0],
                longitude: userLocation.value[1],
                lastSeen: new Date().toISOString()
              }, { merge: true });
            } catch (error) {
              errorMessage.value = 'Failed to update location: ' + error.message;
            }
          }
        }

        // Toggle online/offline status
        async function toggleStatus() {
          status.value = status.value === 'ONLINE' ? 'OFFLINE' : 'ONLINE';
          await updateUserLocation();
          if (status.value === 'ONLINE') {
            fetchNearbyUsers();
          } else {
            nearbyUsers.value = [];
            if (beepInterval) {
              clearInterval(beepInterval);
              beepInterval = null;
            }
          }
        }

        // Change user name
        async function changeName() {
          const newName = prompt('Enter new name:', user.value);
          if (newName) {
            user.value = newName;
            await updateUserLocation();
            if (userMarker) {
              userMarker.setIcon(L.divIcon({
                html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${newName.charAt(0).toUpperCase()}</div>`,
                className: 'user-marker',
                iconSize: [20, 20]
              }));
              userMarker.bindPopup(`<b>${newName}</b><br>Your location`);
            }
          }
        }

        // Calculate distance between coordinates
        function calculateDistance(coord1, coord2) {
          const R = 6371e3;
          const lat1 = coord1[0] * Math.PI / 180;
          const lat2 = coord2[0] * Math.PI / 180;
          const deltaLat = (coord2[0] - coord1[0]) * Math.PI / 180;
          const deltaLon = (coord2[1] - coord1[1]) * Math.PI / 180;
          const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        // Fetch nearby users
        function fetchNearbyUsers() {
          if (!userLocation.value) {
            errorMessage.value = 'Location not available';
            return;
          }
          loadingNearby.value = true;
          const q = db.collection('users').where('status', '==', 'ONLINE');
          q.onSnapshot((snapshot) => {
            nearbyUsers.value = snapshot.docs
              .filter(doc => doc.id !== currentUserId.value)
              .map(doc => {
                const data = doc.data();
                const distance = calculateDistance(userLocation.value, [data.latitude, data.longitude]);
                return { 
                  id: doc.id, 
                  name: data.name, 
                  distance, 
                  lastSeen: data.lastSeen,
                  latitude: data.latitude,
                  longitude: data.longitude
                };
              })
              .filter(user => user.distance < 10000);
            loadingNearby.value = false;
          }, (error) => {
            errorMessage.value = 'Failed to load nearby users: ' + error.message;
            loadingNearby.value = false;
          });
        }

        // Format relative time
        function formatRelativeTime(timestamp) {
          const now = new Date();
          const date = new Date(timestamp);
          const diff = (now - date) / 1000;
          if (diff < 60) return `${Math.floor(diff)} seconds ago`;
          if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
          return `${Math.floor(diff / 3600)} hours ago`;
        }

        // Force refresh
        function forceRefresh() {
          getUserLocation();
          if (status.value === 'ONLINE') fetchNearbyUsers();
        }

        return {
          user,
          status,
          currentUserId,
          userLocation,
          lastLocationUpdate,
          nearbyUsers,
          loadingNearby,
          errorMessage,
          firebaseInitialized,
          soundEnabled,
          clearingStaleLocations,
          mapInitialized,
          toggleStatus,
          changeName,
          toggleSound,
          clearStaleLocations,
          formatRelativeTime,
          forceRefresh
        };
      }
    }).mount('#app');
  </script>
</body>
</html>