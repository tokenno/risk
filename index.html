<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Meet with Friends</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css">
  <style>
    #map { height: 500px; width: 100%; }
    #status { text-align: center; margin: 10px; }
    #permission-message { text-align: center; color: red; display: none; }
    #distance { text-align: center; margin: 0px; display: none; }
    #retry-button, #beacon-button, #sound-button, #test-sound-button { display: none; margin: 0px auto; padding: 8px; }
    .hidden { display: none; }
    .flashing { animation: flash 0s infinite; }
    @keyframes flash { 50% { opacity: 0; } }
    #gender-select, #search-gender-select, #lock-user-select, #name-input { display: none; margin: 0px auto; padding: 0px; }
    .marker-male { background: blue; border-radius: 50%; width: 12px; height: 12px; }
    .marker-female { background: pink; border-radius: 50%; width: 12px; height: 12px; }
    .marker-nonbinary { background: yellow; border-radius: 50%; width: 12px; height: 12px; }
    .marker-you { background: green; border: 0px solid white; border-radius: 0%; width: 20px; height: 20px; }
  </style>
</head>
<body>
  <div id="status">Getting your location...</div>
  <div id="permission-message">
    <h2>Permissions Required</h2>
    <p>This app needs your location to work.</p>
    <p>Please enable location access in your browser.</p>
    <button id="retry-button">Retry</button>
  </div>
  <input id="text" name="text" type="Enter your name" placeholder="Enter your name" maxlength="hidden">
  <select id="gender" class="hidden">
    <option value="" disabled="disabled" selected="selected">Select Gender</option>
    <option value="male">M</option>
    <option value="female">F</option>
    <option value="non-binary">NB</option>
  </select>
  <select id="gender-select">
    <option value="all">All</option>
    <option value="male">M</option>
    <option value="female">F</option>
    <option value="non-binary">NB</option>
  </select>
  <select id="lock-user-select" class="hidden">
    <option value="">No Lock</option>
  </select>
  <button id="beacon-button" class="hidden" disabled>Beacon OFF</button>
  <button id="sound-button" class="hidden">Sound</button>
  <button id="test-sound-button" class="hidden">Test</button>
  <div id="distance" class="hidden">Distance to closest: N/A</div>
  <div id="map"></div>

  <!-- Firebase Modular SDK -->
  <script type="module">
    // Import Firebase
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
    import { getFirestore, collection, doc, setDoc, onSnapshot, GeoPoint } from 'https://www.googleapis.com/firebasejs/10.14.1/firebase-firestore.js';

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDC6wFuBTZHlpvoxmaL5ISEgFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.appspot.com",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Leaflet JS
    import 'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js';

    // Map setup
    const map = L.map('map').setView([0, 0], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // User variables
    let userPosition = null;
    let userMarker = null;
    let otherUsers = {};
    let beaconOn = false;
    let soundOn = false;
    let audioContext = null;
    let oscillator = null;
    let userId = Math.random().toString(36).substring(2); // Random ID
    let userGender = ''; // No default gender
    let userName = ''; // No default name
    let searchGender = 'all'; // Default search all
    let lockedUserId = ''; // No locked user
    let lastBeaconOn = false; // Track beacon for zoom

    // DOM elements
    const statusDiv = document.getElementById('status');
    const permissionMessage = document.getElementById('permission-message');
    const retryButton = document.getElementById('retry-button');
    const beaconButton = document.getElementById('beacon-button');
    const soundButton = document.getElementById('sound-button');
    const testSoundButton = document.getElementById('test-sound-button');
    const genderSelect = document.getElementById('gender-select');
    const nameInput = document.getElementById('name-input');
    const searchGenderSelect = document.getElementById('search-gender-select');
    const lockUserSelect = document.getElementById('lock-user-select');
    const distanceDiv = document.getElementById('distance');

    // Marker icon based on gender
    function getMarkerIcon(gender, isUser = false) {
      const className = isUser ? 'marker-you' : `marker-${gender.replace('non-binary', 'nonbinary')}`;
      return L.divIcon({
        className: className,
        iconSize: [12, 12],
        iconAnchor: [6, 6],
        popupAnchor: [0, -6]
      });
    }

    // Request location
    function requestLocation() {
      statusDiv.textContent = 'Getting your location...';
      permissionMessage.style.display = 'none';
      navigator.geolocation.watchPosition(
        position => {
          userPosition = [position.coords.latitude, position.coords.longitude];
          statusDiv.className = 'hidden';
          nameInput.className = '';
          genderSelect.className = '';
          searchGenderSelect.className = '';
          lockUserSelect.className = '';
          soundButton.className = '';
          testSoundButton.className = '';
          updateUserLocation();
          // Zoom only when beacon is first turned ON
          if (beaconOn && !lastBeaconOn) {
            map.setView(userPosition, 15);
          }
          lastBeaconOn = beaconOn;
        },
        error => {
          statusDiv.className = 'hidden';
          permissionMessage.style.display = 'block';
          console.error('Location error:', error);
        },
        { enableHighAccuracy: true }
      );
    }

    // Update user location and status
    async function updateUserLocation() {
      if (userPosition && userGender && userName) {
        // Update Firebase
        await setDoc(doc(db, 'users', userId), {
          location: new GeoPoint(userPosition[0], userPosition[1]),
          beaconOn: beaconOn,
          gender: userGender,
          name: userName,
          timestamp: new Date()
        }).catch(error => console.error('Firestore write error:', error));

        // Update or create user marker
        if (userMarker) {
          userMarker.setLatLng(userPosition);
          userMarker.setPopupContent(`${userName} (${userGender})`);
          userMarker.setIcon(getMarkerIcon(userGender, true));
        } else {
          userMarker = L.marker(userPosition, {
            icon: getMarkerIcon(userGender, true),
            className: beaconOn ? 'flashing' : ''
          }).addTo(map).bindPopup(`${userName} (${userGender})`);
        }
        if (beaconOn && !lastBeaconOn) {
          userMarker.setIcon(getMarkerIcon(userGender, true));
          map.setView(userPosition, 15);
        }
      }
    }

    // Enable beacon after name and gender
    function checkBeaconEnable() {
      if (userGender && userName) {
        beaconButton.disabled = false;
        beaconButton.className = '';
      } else {
        beaconButton.disabled = true;
      }
    }

    nameInput.addEventListener('input', () => {
      userName = nameInput.value.trim();
      checkBeaconEnable();
      updateUserLocation();
    });

    genderSelect.addEventListener('change', () => {
      userGender = genderSelect.value;
      checkBeaconEnable();
      updateUserLocation();
    });

    // Update search gender
    searchGenderSelect.addEventListener('change', () => {
      searchGender = searchGenderSelect.value;
      updateVisibleUsers();
    });

    // Update locked user
    lockUserSelect.addEventListener('change', () => {
      lockedUserId = lockUserSelect.value;
      if (beaconOn && soundOn) {
        startBeep();
      } else {
        stopBeep();
      }
    });

    // Toggle beacon
    beaconButton.addEventListener('click', () => {
      if (!userGender || !userName) {
        alert('Please enter your name and select your gender first.');
        return;
      }
      beaconOn = !beaconOn;
      beaconButton.textContent = `Beacon ${beaconOn ? 'ON' : 'OFF'}`;
      updateUserLocation();
      if (beaconOn && soundOn) {
        startBeep();
      } else {
        stopBeep();
      }
    });

    // Toggle sound
    soundButton.addEventListener('click', () => {
      soundOn = !soundOn;
      soundButton.textContent = `Sound ${soundOn ? 'ON' : 'OFF'}`;
      if (soundOn && beaconOn) {
        startBeep();
      } else {
        stopBeep();
      }
    });

    // Test sound
    testSoundButton.addEventListener('click', () => {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log('AudioContext initialized for test');
      }
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => console.log('AudioContext resumed'));
      }
      const testOscillator = audioContext.createOscillator();
      testOscillator.type = 'sine';
      testOscillator.frequency.setValueAtTime(440, audioContext.currentTime);
      testOscillator.connect(audioContext.destination);
      testOscillator.start();
      testOscillator.stop(audioContext.currentTime + 0.5);
      console.log('Test sound played');
    });

    // Retry location
    retryButton.addEventListener('click', requestLocation);

    // Web Audio API for beep
    function startBeep() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          console.log('AudioContext initialized');
        } catch (error) {
          console.error('AudioContext initialization failed:', error);
          return;
        }
      }
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => console.log('AudioContext resumed')).catch(error => console.error('AudioContext resume failed:', error));
      }
      updateBeep();
    }

    function stopBeep() {
      if (oscillator) {
        oscillator.stop();
        oscillator = null;
        console.log('Beep stopped');
      }
    }

    function updateBeep() {
      if (!beaconOn || !soundOn || !audioContext || audioContext.state !== 'running') {
        stopBeep();
        distanceDiv.textContent = 'Distance to closest user: N/A';
        distanceDiv.className = 'hidden';
        console.log('Beep not started: beaconOn=', beaconOn, 'soundOn=', soundOn, 'audioContext.state=', audioContext?.state);
        return;
      }

      // Find closest or locked user
      let minDistance = Infinity;
      let closestUser = null;
      let targetUserId = lockedUserId || null;
      Object.values(otherUsers).forEach(user => {
        if (user.beaconOn && user.location && (!targetUserId || user.id === targetUserId)) {
          if (searchGender === 'all' || user.gender === searchGender) {
            const distance = map.distance(userPosition, [user.location.latitude, user.location.longitude]);
            if (distance < minDistance) {
              minDistance = distance;
              closestUser = user;
            }
          }
        }
      });

      // Beep within 20 meters, 20-180 BPM
      const maxDistance = 20;
      const minDistanceThreshold = 5;
      const minFrequency = 20 / 60; // 20 BPM = 0.33 Hz
      const maxFrequency = 180 / 60; // 180 BPM = 3 Hz
      let frequency = minDistance <= maxDistance
        ? minFrequency + (maxFrequency - minFrequency) * Math.max(0, (maxDistance - Math.max(minDistance, minDistanceThreshold)) / (maxDistance - minDistanceThreshold))
        : 0;

      if (frequency > 0) {
        distanceDiv.textContent = `Distance to ${lockedUserId ? 'locked' : 'closest'} user: ${minDistance.toFixed(2)} meters`;
        distanceDiv.className = '';
        if (!oscillator) {
          try {
            oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.connect(audioContext.destination);
            oscillator.start();
            console.log('Beep started, distance:', minDistance.toFixed(2), 'meters, frequency:', (frequency * 60).toFixed(2), 'BPM');
          } catch (error) {
            console.error('Oscillator creation failed:', error);
            return;
          }
        }
        oscillator.stop(audioContext.currentTime + 0.1);
        oscillator = audioContext.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.connect(audioContext.destination);
        oscillator.start(audioContext.currentTime);
        setTimeout(updateBeep, 1000 / frequency);
      } else {
        stopBeep();
        distanceDiv.textContent = 'Distance to closest user: N/A';
        distanceDiv.className = 'hidden';
        console.log('No users within', maxDistance, 'meters or matching search criteria');
      }
    }

    // Update visible users
    function updateVisibleUsers() {
      const now = new Date().getTime();
      const staleThreshold = 30 * 1000; // 30 seconds
      Object.keys(otherUsers).forEach(id => {
        const user = otherUsers[id];
        const userTimestamp = user.timestamp ? user.timestamp.toDate().getTime() : 0;
        if (!user.beaconOn || (now - userTimestamp) > staleThreshold) {
          if (user.marker._map) {
            map.removeLayer(user.marker);
          }
          delete otherUsers[id];
        } else if (user.beaconOn && user.location) {
          const shouldShow = searchGender === 'all' || user.gender === searchGender;
          if (shouldShow && !user.marker._map) {
            user.marker.addTo(map);
          } else if (!shouldShow && user.marker._map) {
            map.removeLayer(user.marker);
          }
        }
      });
      // Update lock user dropdown
      lockUserSelect.innerHTML = '<option value="">No Lock</option>';
      Object.keys(otherUsers).forEach(id => {
        const user = otherUsers[id];
        if (user.beaconOn && (searchGender === 'all' || user.gender === searchGender)) {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = `${user.name || 'User'} (${user.gender})`;
          lockUserSelect.appendChild(option);
        }
      });
      if (beaconOn && soundOn) {
        startBeep();
      }
    }

    // Listen for users
    function initializeUserListener() {
      // Clear existing users
      Object.keys(otherUsers).forEach(id => {
        if (otherUsers[id].marker._map) {
          map.removeLayer(otherUsers[id].marker);
        }
      });
      otherUsers = {};

      onSnapshot(collection(db, 'users'), snapshot => {
        const now = new Date().getTime();
        const staleThreshold = 30 * 1000; // 30 seconds
        snapshot.forEach(doc => {
          const data = doc.data();
          const id = doc.id;
          if (id === userId) return;

          const timestamp = data.timestamp ? data.timestamp.toDate().getTime() : 0;
          if (data.beaconOn && (now - timestamp) <= staleThreshold) {
            const latlng = [data.location.latitude, data.location.longitude];
            const gender = data.gender || 'unknown';
            const name = data.name || 'User';
            if (otherUsers[id]) {
              otherUsers[id].marker.setLatLng(latlng);
              otherUsers[id].marker.setPopupContent(`${name} (${gender})`);
              otherUsers[id].marker.setIcon(getMarkerIcon(gender));
              otherUsers[id].location = data.location;
              otherUsers[id].beaconOn = data.beaconOn;
              otherUsers[id].gender = gender;
              otherUsers[id].name = name;
              otherUsers[id].timestamp = data.timestamp;
              otherUsers[id].id = id;
            } else {
              otherUsers[id] = {
                marker: L.marker(latlng, {
                  icon: getMarkerIcon(gender)
                }).bindPopup(`${name} (${gender})`),
                location: data.location,
                beaconOn: data.beaconOn,
                gender: gender,
                name: name,
                timestamp: data.timestamp,
                id: id
              };
              if (searchGender === 'all' || gender === searchGender) {
                otherUsers[id].marker.addTo(map);
              }
            }
          } else if (otherUsers[id]) {
            if (otherUsers[id].marker._map) {
              map.removeLayer(otherUsers[id].marker);
            }
            delete otherUsers[id];
          }
        });
        updateVisibleUsers();
        if (beaconOn && soundOn) updateBeep();
      }, error => console.error('Firestore snapshot error:', error));
    }

    // Initialize
    initializeUserListener();
    requestLocation();
  </script>
</body>
</html>
