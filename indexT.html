<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sly App</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
/* General Styles */
:root {
  --primary-color: #2e4053;
  --secondary-color: #6c757d;
  --accent-color: #cd6155;
  --danger-color: #dc3545;
  --background-dark: #121212;
  --surface-dark: #1e1e1e;
  --text-primary: #fae5d3;
  --text-secondary: #b0b0b0;
  --border-color: #333;
  --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  --transition: all 0.3s ease;
}

body {
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: 0;
  padding: 16px;
  background-color: var(--background-dark);
  color: var(--text-primary);
  line-height: 1.6;
}

/* Container */
.container {
  max-width: 800px;
  margin: 0 auto;
  background: var(--surface-dark);
  border-radius: 12px;
  padding: 20px;
  box-shadow: var(--shadow);
  position: relative;
}

/* Sections */
.section {
  margin-bottom: 20px;
  padding: 16px;
  background: linear-gradient(145deg, #222, #1a1a1a);
  border-radius: 8px;
  border: 1px solid var(--border-color);
}

/* Headings */
h3 {
  margin: 0 0 12px;
  font-size: 1.25rem;
  font-weight: 500;
  color: var(--text-primary);
  letter-spacing: 0.5px;
}

/* Buttons */
button {
  padding: 10px 16px;
  background: var(--primary-color);
  color: var(--text-primary);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  transition: var(--transition);
  margin-right: 8px;
  margin-bottom: 8px;
}

button:hover {
  background: #273746;
  transform: translateY(-1px);
}

button:active {
  transform: translateY(0);
}

button.warning {
  background: var(--danger-color);
}

button.warning:hover {
  background: #c82333;
}

button.secondary {
  background: var(--secondary-color);
}

button.secondary:hover {
  background: #5a6268;
}

button.active {
  background: var(--accent-color);
  box-shadow: 0 0 0 2px var(--accent-color);
}

button.following {
  background: var(--primary-color);
}

button.following:hover {
  background: #0056b3;
}

button.online-status {
  animation: onlinePulse 4s infinite;
}
    
    .map-hidden {
  display: none;
}

/* Error Messages */
.error {
  color: var(--danger-color);
  font-size: 0.85rem;
  margin-top: 8px;
}

/* User List */
.user-list div {
  padding: 12px;
  border-bottom: 1px solid var(--border-color);
  transition: var(--transition);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
}

.user-list div:hover {
  background: #2a2a2a;
}

.user-list div.selected {
  background: #2a2a2a;
  border-left: 4px solid var(--accent-color);
}

.user-list div:last-child {
  border-bottom: none;
}

.user-list input[type="checkbox"] {
  accent-color: var(--accent-color);
  cursor: pointer;
}

.user-list input[type="checkbox"]:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Map */
#map {
  height: 320px;
  width: 100%;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  margin-top: 12px;
  background: var(--background-dark);
}

.map-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
}

.map-controls {
  margin-top: 12px;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

/* Audio Permission */
.audio-permission {
  background: #2a2a2a;
  padding: 16px;
  border-radius: 8px;
  margin-bottom: 16px;
  text-align: center;
}

/* User Info */
.user-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.user-info > span {
  width: 40px;
  height: 40px;
  background-color: var(--danger-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 1.2rem;
}

.user-info > div > div:first-child {
  font-weight: 500;
  margin-bottom: 4px;
}

/* Button Group */
.button-group {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 12px;
}

.button-group input[type="number"] {
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  background: #2a2a2a;
  color: var(--text-primary);
  width: 120px;
}

/* Poke Cooldown */
.poke-cooldown {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-top: 8px;
}

/* Animations */
@keyframes blink {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}

.blinking-marker {
  animation: blink 2s infinite;
}

.received-location-marker {
  animation: blink 1s infinite;
  background-color: #ff00ff !important;
}

@keyframes flash {
  0% { background-color: #ffd700; }
  50% { background-color: transparent; }
  100% { background-color: #ffd700; }
}

.flash-user {
  animation: flash 1s ease-in-out infinite;
}

@keyframes onlinePulse {
  0% { background-color: var(--accent-color); }
  50% { background-color: var(--danger-color); }
  100% { background-color: var(--accent-color); }
}

/* Help Panel */
.help-panel {
  position: fixed;
  top: 0;
  right: -400px;
  width: 350px;
  height: 100%;
  background: var(--surface-dark);
  z-index: 1000;
  transition: right var(--transition);
  padding: 20px;
  overflow-y: auto;
  box-shadow: var(--shadow);
}

.help-panel.open {
  right: 0;
}

.help-panel h3 {
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 12px;
}

.help-panel p {
  margin-bottom: 16px;
}

.help-panel ul {
  padding-left: 20px;
  margin-bottom: 16px;
}

.help-panel li {
  margin-bottom: 8px;
}

.help-panel button.close-help {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--danger-color);
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.help-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  z-index: 999;
  display: none;
}

.help-overlay.visible {
  display: block;
}

/* Debug Panel */
.debug-panel {
  position: fixed;
  bottom: -350px;
  left: 150;
  width: 43%;
  background: var(--surface-dark);
  z-index: 1000;
  transition: bottom var(--transition);
  padding: 20px;
  border-top: 1px solid var(--border-color);
  box-shadow: var(--shadow);
  max-height: 250px;
  overflow-y: auto;
}

.debug-panel.open {
  bottom: 0;
}

.close-debug {
  position: absolute;
  top: 12px;
  right: 12px;
  background: var(--danger-color);
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Message Styles */
.message-signin-prompt {
  background: #2a2a2a;
  padding: 16px;
  border-radius: 8px;
  text-align: center;
  margin-bottom: 12px;
}

.messages-container {
  margin-top: 12px;
  max-height: 250px;
  overflow-y: auto;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px;
}

.message {
  padding: 8px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.message:last-child {
  border-bottom: none;
}

.message.sent {
  background: #80b7da;
  color: #000;
}
.message small {
  color: var(--text-primary); /* Changed to white */
  font-size: 0.8rem;
}
.message.received {
  background: var(--primary-color);
  color: var(--text-primary);
}


/* Message Alert */
.message-alert {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--primary-color);
  padding: 12px 24px;
  border-radius: 8px;
  font-weight: 500;
  box-shadow: var(--shadow);
  z-index: 1001;
  cursor: pointer;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

/* Message Panel */
.message-panel {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 320px;
  background: var(--surface-dark);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  z-index: 1000;
  box-shadow: var(--shadow);
  display: flex;
  flex-direction: column;
}

.message-panel-header {
  padding: 12px;
  background: #222;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.message-panel-body {
  padding: 12px;
  flex-grow: 1;
  overflow-y: auto;
  max-height: 300px;
}

.message-panel-footer {
  padding: 12px;
  border-top: 1px solid var(--border-color);
  display: flex;
  gap: 8px;
}

.message-panel-footer input {
  flex-grow: 1;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  background: #2a2a2a;
  color: var(--text-primary);
}

.message-notification {
  position: relative;
}

.message-notification-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  background: var(--danger-color);
  color: var(--text-primary);
  border-radius: 50%;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: 600;
}

/* Responsive Design */
@media (max-width: 768px) {
  .container {
    padding: 12px;
  }

  .section {
    padding: 12px;
  }

  #map {
    height: 50vh;
  }
    .map-hidden {
  display: none;
}

  .button-group {
    flex-direction: column;
  }

  .button-group button {
    width: 100%;
    margin-right: 0;
  }

  .user-list {
    flex-direction: column;
    align-items: flex-start;
  }

  .help-panel {
    width: 100%;
    right: -100%;
  }

  .help-panel.open {
    right: 0;
  }

  .message-panel {
    width: calc(100% - 48px);
    left: 24px;
    right: 24px;
  }
}

@media (max-width: 480px) {
  button {
    padding: 8px 12px;
    font-size: 0.85rem;
  }

  h3 {
    font-size: 1.1rem;
  }

  .user-info > span {
    width: 32px;
    height: 32px;
    font-size: 1rem;
  }
}
    </style>
</head>
<body>
  <div id="app" class="container">
      <div 
  v-if="showMessageAlert && messageAlert" 
  class="message-alert" 
  @click="dismissMessageAlert"
>
  📩 New message from {{ messageAlert.from }} – click to open
</div>

    <!-- Help Panel -->
    <div class="help-overlay" :class="{ visible: showHelp }" @click="toggleHelp"></div>
    <div class="help-panel" :class="{ open: showHelp }">
      <button class="close-help" @click="toggleHelp">×</button>
      <h3>Sly</h3>
      <p>A location-based social networking app, capturing the essence of connecting with nearby users in various ways.</p>
     
            <h3>Important!</h3>
      <ul>
        <li>Only your GPS Position DATA are saved in the app and <strong>only while you using it. </strong></li>
        <li>After one hour of inactivity <strong>all DATA are delete from the server</strong>, no matter. </li>
        <li>Even if Go Online is On and you leave the app, <strong>your GPS Point beacon stops.</strong> </li>
        <li>We want to keep Sly <strong>open</strong> but <strong>safe.</strong> </li>
      </ul>
        
        <h3>Basic Functions</h3>
      <ul>
  <li><strong>Go Online/Offline:</strong> Toggle your visibility to other users.</li>
        <li><strong>Change Name:</strong> Update your display name.</li>
        <li><strong>Sound On/Off:</strong> Toggle audio notifications.</li>
        <li><strong>Help:</strong> Show/hide this help panel.</li>
      </ul>
      <h3>Map Controls</h3>
      <ul>
        <li><strong>Focus on Me:</strong> Center the map on your location.</li>
        <li><strong>Share Position:</strong> Share your location with another user.</li>
        <li><strong>Stop Sharing:</strong> Stop sharing your location.</li>
      </ul>
      <h3>User Interactions</h3>
      <ul>
        <li><strong>Follow:</strong> Track another user's location.</li>
        <li><strong>Poke:</strong> Send a notification to another user.</li>
        <li><strong>Send Location:</strong> Share your current location once.</li>
      </ul>
      <h3>Groups</h3>
      <ul>
        <li>Create temporary groups by selecting specific nearby users.</li>
        <li>Check the boxes next to users to include them in the group.</li>
        <li>Click "Create Group with Selected Users" to form the group.</li>
        <li>Enable Alerts when members of the group are outside a specified distance from your position.</li>
        <li>Clear group to return to seeing all users.</li>
      </ul>
      <h3>Audio Features</h3>
      <ul>
        <li>Each nearby user has a unique sound signature.</li>
        <li>Sounds change based on distance and direction.</li>
        <li>Toggle between different musical scales.</li>
      </ul>
      <h3>Scenarios</h3>
      <ul>
        <li><strong>Social Events:</strong> Share your location, follow friends and use the map to navigate to their position.</li>
        <li><strong>Group Activities:</strong> You're organizing a scavenger hunt with a group of players.</li>
        <li><strong>Safety and Coordination:</strong> You're hiking with friends and want to ensure no one gets lost.</li>
        <li><strong>Casual Meetups:</strong> You're in a new city and want to connect with nearby users.</li>
        <li><strong>Nightlife Connections:</strong> At a club or a party, use Sly to spot nearby users.</li>
        
      </ul>
       
    </div>
  

<div class="section">
  <div style="display: flex; align-items: center; gap: 12px;">
    <img src="sly-trans-512.png" alt="Sly Logo" width="100" height="100" style="vertical-align: middle;">
 
  </div>
</div>

    <div class="section">
      <h3>Your Location</h3>
      <div v-if="locationStatus === 'loading'">Acquiring your location...</div>
      <div v-else-if="locationStatus === 'unavailable'">Location not available or waiting to load map</div>
      <div v-else>
        <div v-if="!followedUserId">Latitude: {{ userLocation[0].toFixed(6) }}</div>
        <div v-if="!followedUserId">Longitude: {{ userLocation[1].toFixed(6) }}</div>
    
          <div v-if="followedUserId">Following: {{ followedUserName }} (Lat: {{ followedUserLocation[0].toFixed(6) }}, Lon: {{ followedUserLocation[1].toFixed(6) }})</div>
   
  <div id="map" :class="{ 'map-hidden': !mapInitialized }">
  <div v-if="!mapInitialized" class="map-loading">Loading map...</div>
</div>
        <div class="map-controls" v-if="mapInitialized">
          <button class="secondary" @click="focusOnMyLocation">Focus on {{ followedUserId ? 'Me' : 'Me' }}</button>
         <button @click="toggleDebugPanel" class="secondary">Debug</button>
      <button @click="toggleHelp" class="secondary">Help</button>
        </div>
      </div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
    </div>

    <div class="section">
      <div v-if="user" class="user-info">
        <span>{{ user.charAt(0).toUpperCase() }}</span>
        <div>
          <div>{{ user }}</div>
              
          <div v-if="status === 'ONLINE'">Currently online</div>
          <div v-else>Currently offline</div>
   
        </div>
      </div>
        <br>
         <div class="message-notification">
      <button @click="toggleStatus" :class="{ 'online-status': status === 'ONLINE' }">{{ status === 'ONLINE' ? 'Go Offline' : 'Go Online' }}</button>
        
      <button @click="changeName">Change Name</button>
         <button @click="toggleSound">{{ soundEnabled ? '🔔 Sound On' : '🔕 Sound Off' }}</button>
     
        <button @click="toggleMessagePanel" class="message-boxes">
          Messages
          <span v-if="unreadMessageCount > 0" class="message-notification-badge">{{ unreadMessageCount }}</span>
              
        </button>
      </div>
   
     
 
    </div>

    <div class="section audio-permission" v-if="showAudioPermission">
      <h3>Audio Permission Required</h3>
      <p>Please tap the button below to enable sound notifications</p>
      <button @click="enableAudio">Enable Sound</button>
    </div>

    <div class="section" v-if="groupUsers.length > 0">
      <h3>Group Alerts</h3>
      <div class="button-group">
        <button @click="enableGroupAlerts = !enableGroupAlerts" :class="{ active: enableGroupAlerts }">
          {{ enableGroupAlerts ? 'Disable Alerts' : 'Enable Alerts' }}
        </button>
        <input 
          type="number" 
          v-model="groupAlertDistance" 
          min="10" 
          max="10000" 
          placeholder="Distance (meters)"
          :disabled="!enableGroupAlerts"
        >
      </div>
      <div v-if="groupAlertMessage" class="error">{{ groupAlertMessage }}</div>
    </div>

    <div class="section">
      <h3>Nearby Users ({{ groupUsers.length || nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000).length }})</h3>
      <div v-if="!groupUsers.length" class="button-group">
        <button class="secondary" @click="createGroupFromSelected" :disabled="selectedUsersForGroup.length === 0">
          Create Group with Selected Users
        </button>
          <div 
  :key="user.id" 
  class="user-list"
  :class="{ selected: selectedUser?.id === user.id }"
  :data-user-id="user.id"
>
          </div>
      </div>
      <div v-else class="button-group">
        <p>Group of {{ groupUsers.length }} users</p>
        <button class="secondary" @click="clearGroup">Clear Group</button>
      </div>
      <div class="button-group">
        <button 
          v-for="distance in distanceOptions" 
          :key="distance.value"
          :class="{ active: selectedDistance === distance.value }"
          @click="selectDistance(distance.value)"
        >
          {{ distance.label }}
        </button>
      </div>
   <button v-if="selectedUser && selectedUser.id" @click="pokeUser" class="secondary" :disabled="isPokeCooldown">
  Poke {{ selectedUser.name }}
</button>
      <button 
        v-if="selectedUser" 
        @click="sendLocation"
        class="secondary"
      >
        Send Location to {{ selectedUser.name }}
      </button>
          
          <div class="section" v-if="selectedUser">
  <h3>Messages</h3>
  <div v-if="!isSignedIn" class="message-signin-prompt">
    <p>Sign in to send messages to {{ selectedUser.name }}</p>
    <button @click="signIn" class="secondary">Sign In</button>
  </div>
  <div v-else>
    <div class="button-group">
      <input 
        type="text" 
        v-model="messageText" 
        placeholder="Type your message"
        @keyup.enter="sendMessage"
      >
      <button @click="sendMessage" :disabled="!messageText">Send</button>
    </div>
  </div>
  <div v-if="messages.length > 0" class="messages-container">
  <div v-for="msg in messages" :key="msg.id" 
     class="message" 
     :class="{ 'sent': msg.from === 'You', 'received': msg.from !== 'You' }">
  <strong>{{ msg.from }}:</strong> {{ msg.text }}
  <small>{{ formatRelativeTime(msg.timestamp) }}</small>
</div>
  </div>
</div>
      <div v-if="isPokeCooldown" class="poke-cooldown">
        Poke available in {{ pokeCooldownSeconds }} seconds
      </div>
      <div v-if="loadingNearby">Loading nearby users...</div>
      <div v-if="!loadingNearby && nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000).length === 0 && !groupUsers.length">No users nearby</div>
      <div v-if="groupUsers.length">
        <div v-for="user in groupUsers" 
             :key="user.id" 
             class="user-list"
             :class="{ selected: selectedUser?.id === user.id }"
             @click="selectUser(user)">
          <div>{{ user.name }}</div>
          <div v-if="user.distance < 1000">{{ user.distance }}m away</div>
          <div v-else>{{ (user.distance/1000).toFixed(1) }}km away</div>
          <div>{{ formatRelativeTime(user.lastSeen) }}</div>
          <button 
            v-if="user.id !== currentUserId" 
            @click.stop="toggleFollow(user)"
            :class="{ following: followedUserId === user.id }"
            class="secondary"
          >
            {{ followedUserId === user.id ? 'Unfollow' : 'Follow' }}
          </button>
        </div>
      </div>
      <div v-else>
        <div v-for="user in nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000)" 
             :key="user.id" 
             class="user-list"
             :class="{ selected: selectedUser?.id === user.id }">
          <input 
            type="checkbox" 
            :value="user.id" 
            v-model="selectedUsersForGroup" 
            @click.stop 
            :disabled="user.id === currentUserId"
          >
          <div @click="selectUser(user)">{{ user.name }}</div>
          <div @click="selectUser(user)" v-if="user.distance < 1000">{{ user.distance }}m away</div>
          <div @click="selectUser(user)" v-else>{{ (user.distance/1000).toFixed(1) }}km away</div>
            <div @click="selectUser(user)" v-if="user.distance === null">Global user</div>
          <div @click="selectUser(user)">{{ formatRelativeTime(user.lastSeen) }}</div>
          <button 
            v-if="user.id !== currentUserId" 
            @click.stop="toggleFollow(user)"
            :class="{ following: followedUserId === user.id }"
            class="secondary"
          >
            {{ followedUserId === user.id ? 'Unfollow' : 'Follow' }}
          </button>
        </div>
      </div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
    </div>

 <div class="debug-panel" :class="{ open: showDebugPanel }">
  <button class="close-debug" @click="toggleDebugPanel">×</button>
  <h3>Debug Information</h3>
  <div>Firebase: {{ firebaseInitialized ? 'Connected' : 'Disconnected' }}</div>
  <div>User ID: {{ currentUserId || 'Not set' }}</div>
  <div>Location: {{ userLocation ? 'Valid' : 'Invalid' }}</div>
  <div>Last Update: {{ lastLocationUpdate ? new Date(lastLocationUpdate).toLocaleTimeString() : 'Never' }}</div>
  <div v-if="activeSoundProfiles.length > 0">
    Active sounds: 
    <span v-for="profile in activeSoundProfiles" :key="profile.id">
      {{ profile.name }} ({{ profile.frequency.toFixed(0) }}Hz)
    </span>
  </div>
  <div>Audio State: {{ audioState }}</div>
  <div>
    Musical Scale: 
    <select v-model="currentScaleName" @change="updateScale">
      <option value="pentatonic">Pentatonic</option>
      <option value="major">Major</option>
      <option value="minor">Minor</option>
      <option value="chromatic">Chromatic</option>
    </select>
  </div>
  <button @click="forceRefresh">Force Refresh</button>
</div>

<!-- Message Panel -->
<div class="message-panel" v-if="showMessagePanel">
  <div class="message-panel-header">
    <h3>Messages</h3>
    <div>
      <button @click="clearMessages" class="secondary" style="margin-right: 5px;">Clear</button>
      <button @click="toggleMessagePanel" class="secondary">×</button>
    </div>
  </div>
  <div class="message-panel-body">
    <div class="message-recipient-selector">
      <select v-model="messageRecipientType">
        <option value="user">Send to User</option>
        <option value="group" :disabled="!groupUsers.length">Send to Group</option>
      </select>
      <select v-if="messageRecipientType === 'user'" v-model="selectedMessageRecipient">
        <option v-for="user in nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000)" 
                :value="user.id" 
                :key="user.id">
          {{ user.name }}
        </option>
      </select>
    </div>
    <div class="messages-container">
      <div v-for="msg in messages" :key="msg.id" 
           class="message" 
           :class="{ 'sent': msg.from === 'You', 'received': msg.from !== 'You' }">
        <strong>{{ msg.from }}:</strong> {{ msg.text }}
        <small>{{ formatRelativeTime(msg.timestamp) }}</small>
      </div>
    </div>
  </div>
  <div class="message-panel-footer">
    <input 
      type="text" 
      v-model="panelMessageText" 
      placeholder="Type your message"
      @keyup.enter="sendPanelMessage"
      style="width: calc(100% - 70px); margin-right: 5px;"
    >
    <button @click="sendPanelMessage" :disabled="!panelMessageText">Send</button>
  </div>
</div>

  <!-- Message alert sound (hidden) -->
  <audio class="message-alert-sound" src="incmess.mp3" preload="auto"></audio>

  <script>
    const { createApp, ref, onMounted, watch, nextTick } = Vue;

    const firebaseConfig = {
      apiKey: "AIzaSyDC6w15EQdfuBTZHlpvoxmaL5ISEgbFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.appspot.com",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    let app, db, auth;
    function initializeFirebase() {
      try {
        if (typeof firebase === 'undefined') {
          throw new Error('Firebase SDK not loaded');
        }
        app = firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        auth = firebase.auth();
        firebase.analytics();
        return true;
      } catch (error) {
        console.error('Firebase initialization failed:', error);
        return false;
      }
    }

    const scales = {
      pentatonic: [0, 2, 4, 7, 9],
      major: [0, 2, 4, 5, 7, 9, 11],
      minor: [0, 2, 3, 5, 7, 8, 10],
      chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    };
    const rootNote = 60;

    createApp({
      setup() {
        const user = ref(null);
        const status = ref('OFFLINE');
        const currentUserId = ref(null);
        const userLocation = ref(null);
        const lastLocationUpdate = ref(null);
        const nearbyUsers = ref([]);
        const loadingNearby = ref(false);
        const errorMessage = ref('');
        const firebaseInitialized = ref(false);
        const soundEnabled = ref(true);
        const clearingStaleLocations = ref(false);
        const mapInitialized = ref(false);
        const selectedUser = ref(null);
        const activeSoundProfiles = ref([]);
        const showAudioPermission = ref(true);
        const audioState = ref('Not initialized');
      const distanceOptions = ref([
  { label: '100m', value: 100, zoom: 18 },
  { label: '1km', value: 1000, zoom: 15 },
  { label: '50km', value: 50000, zoom: 11 },
  { label: '150km', value: 150000, zoom: 9 },
  { label: '500km', value: 500000, zoom: 7 },
  { label: 'Global', value: Infinity, zoom: 3 }
        
        ]);
        const selectedDistance = ref(1000);
        const locationStatus = ref('loading');
        const currentScaleName = ref('pentatonic');
        const currentScale = ref(scales.pentatonic);
        const lastPokeTime = ref(0);
        const isPokeCooldown = ref(false);
        const pokeCooldownSeconds = ref(0);
        const followedUserId = ref(null);
        const followedUserName = ref('');
        const followedUserLocation = ref(null);
        const groupUsers = ref([]);
        const isSharingPosition = ref(false);
        const positionShareInterval = ref(null);
        const lastKnownUsernames = ref({});
        const showHelp = ref(false);
        const selectedUsersForGroup = ref([]);
        const enableGroupAlerts = ref(false);
        const groupAlertDistance = ref(100); // default 100 meters
        const groupAlertMessage = ref('');
        const lastAlertTimes = ref({});
        const groupAlertCheckInterval = ref(null);
        let map = null;
        let userMarker = null;
        let nearbyMarkers = [];
        let selectedUserMarker = null;
        let audioContext = null;
        const userBeepIntervals = new Map();
        const userSoundProfiles = new Map();
        const colors = ['#3498db', '#2ecc71', '#e74c3c', '#9b59b6', '#f1c40f', '#1abc9c', '#e67e22'];
          const messageAlert = ref(null); // { from: 'Name', fromId: 'uid' }
const showMessageAlert = ref(false);

          
          const showDebugPanel = ref(false);
            const isSignedIn = ref(false);
  const messageText = ref('');
  const messages = ref([]);
  const showMessagePanel = ref(false);
  const unreadMessageCount = ref(0);
  const panelMessageText = ref('');
  const messageRecipientType = ref('user');
  const selectedMessageRecipient = ref(null);

function toggleDebugPanel() {
  showDebugPanel.value = !showDebugPanel.value;
}

function toggleMessagePanel() {
  showMessagePanel.value = !showMessagePanel.value;
  if (showMessagePanel.value) {
    unreadMessageCount.value = 0;
  }
}

async function clearMessages() {
  messages.value = [];
  if (currentUserId.value) {
    try {
      await db.collection('users').doc(currentUserId.value).update({
        messages: firebase.firestore.FieldValue.delete()
      });
    } catch (error) {
      console.error('Error clearing messages:', error);
    }
  }
}

async function sendPanelMessage() {
  if (!panelMessageText.value.trim()) return;

  if (messageRecipientType.value === 'group' && groupUsers.value.length > 0) {
    // Send to group
    const promises = groupUsers.value
      .filter(user => user.id !== currentUserId.value)
      .map(user => {
        return db.collection('users').doc(user.id).update({
          messages: firebase.firestore.FieldValue.arrayUnion({
            from: user.value,
            fromId: currentUserId.value,
            text: panelMessageText.value,
            timestamp: new Date().toISOString()
          })
        });
      });

    try {
      await Promise.all(promises);
      messages.value.push({
        from: 'You',
        text: panelMessageText.value,
        timestamp: new Date().toISOString()
      });
      panelMessageText.value = '';
    } catch (error) {
      errorMessage.value = "Failed to send group message: " + error.message;
    }
  } else if (messageRecipientType.value === 'user' && selectedMessageRecipient.value) {
    // Send to individual user
    try {
      await db.collection('users').doc(selectedMessageRecipient.value).update({
        messages: firebase.firestore.FieldValue.arrayUnion({
          from: user.value,
          fromId: currentUserId.value,
          text: panelMessageText.value,
          timestamp: new Date().toISOString()
        })
      });
      
      messages.value.push({
        from: 'You',
        text: panelMessageText.value,
        timestamp: new Date().toISOString()
      });
      panelMessageText.value = '';
    } catch (error) {
      errorMessage.value = "Failed to send message: " + error.message;
    }
  }
}

        const pokeCooldownInterval = setInterval(() => {
          if (isPokeCooldown.value) {
            const now = Date.now();
            const remaining = Math.ceil((lastPokeTime.value + 5000 - now) / 1000);
            if (remaining > 0) {
              pokeCooldownSeconds.value = remaining;
            } else {
              isPokeCooldown.value = false;
              pokeCooldownSeconds.value = 0;
            }
          }
        }, 200);
          
          function updateMapLocation(newLocation) {
  if (!map || !newLocation) return;
  
  if (userMarker) {
    userMarker.setLatLng(newLocation);
  } else {
    userMarker = L.marker(newLocation, {
      icon: L.divIcon({
        html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
        className: 'user-marker blinking-marker',
        iconSize: [20, 20]
      })
    }).addTo(map).bindPopup(`<b>${user.value}</b><br>Your location`);
  }
  
  if (!followedUserId.value) {
    map.setView(newLocation, 18);
  }
}

        function toggleHelp() {
          showHelp.value = !showHelp.value;
        }

        async function sharePosition() {
          if (!userLocation.value) return;
          
          try {
            isSharingPosition.value = true;
            await db.collection('sharedPositions').doc(currentUserId.value).set({
              userId: currentUserId.value,
              userName: user.value,
              latitude: userLocation.value[0],
              longitude: userLocation.value[1],
              timestamp: new Date().toISOString()
            });
            
            positionShareInterval.value = setInterval(async () => {
              if (userLocation.value) {
                await db.collection('sharedPositions').doc(currentUserId.value).update({
                  latitude: userLocation.value[0],
                  longitude: userLocation.value[1],
                  timestamp: new Date().toISOString()
                });
              }
            }, 10000);
            
            console.log('Started sharing position');
          } catch (error) {
            errorMessage.value = "Failed to share position: " + error.message;
            isSharingPosition.value = false;
            if (positionShareInterval.value) {
              clearInterval(positionShareInterval.value);
              positionShareInterval.value = null;
            }
          }
        }

        watch([groupUsers, enableGroupAlerts, userLocation], ([newGroupUsers, newEnableAlerts, newUserLocation]) => {
          if (groupAlertCheckInterval.value) {
            clearInterval(groupAlertCheckInterval.value);
            groupAlertCheckInterval.value = null;
          }
          
          if (newEnableAlerts && newGroupUsers.length > 0 && newUserLocation) {
            groupAlertCheckInterval.value = setInterval(checkGroupDistances, 5000);
          }
        }, { immediate: true });

        function checkGroupDistances() {
          if (!enableGroupAlerts.value || !userLocation.value || groupUsers.value.length === 0) return;
          
          const now = Date.now();
          groupUsers.value.forEach(user => {
            const distance = calculateDistance(userLocation.value, [user.latitude, user.longitude]);
            
            if (distance > groupAlertDistance.value) {
              if (!lastAlertTimes.value[user.id] || (now - lastAlertTimes.value[user.id]) > 60000) {
                groupAlertMessage.value = `${user.name} is now ${distance < 1000 ? distance.toFixed(0) + 'm' : (distance/1000).toFixed(1) + 'km'} away!`;
                alert(groupAlertMessage.value);
                lastAlertTimes.value[user.id] = now;
                
                if (soundEnabled.value && audioContext && audioContext.state === 'running') {
                  playAlertSound();
                }
              }
            }
          });
        }
          
          // Helper functions for localStorage
function getStoredUsername() {
  return localStorage.getItem('sly_username');
}

function storeUsername(username) {
  if (username) {
    localStorage.setItem('sly_username', username);
  }
}

function clearStoredUsername() {
  localStorage.removeItem('sly_username');
}

        function playAlertSound() {
          if (!audioContext || audioContext.state !== 'running') return;
          
          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 800;
            gain.gain.value = 0.5;
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
            osc.connect(gain).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 1.0);
          } catch (error) {
            console.error('Alert sound error:', error);
          }
        }

        async function stopSharingPosition() {
          try {
            await db.collection('sharedPositions').doc(currentUserId.value).delete();
            isSharingPosition.value = false;
            if (positionShareInterval.value) {
              clearInterval(positionShareInterval.value);
              positionShareInterval.value = null;
            }
            console.log('Stopped sharing position');
          } catch (error) {
            errorMessage.value = "Failed to stop sharing position: " + error.message;
          }
        }

        async function sendLocation() {
          if (!selectedUser.value || !userLocation.value) return;
          
          try {
            await db.collection('users').doc(selectedUser.value.id).update({
              receivedLocation: {
                from: user.value,
                fromId: currentUserId.value,
                latitude: userLocation.value[0],
                longitude: userLocation.value[1],
                timestamp: new Date().toISOString()
              }
            });
            console.log(`Sent location to ${selectedUser.value.name}`);
            alert(`Location sent to ${selectedUser.value.name}`);
          } catch (error) {
            errorMessage.value = "Failed to send location: " + error.message;
          }
        }

        function updateScale() {
          currentScale.value = scales[currentScaleName.value];
          if (soundEnabled.value && audioContext && audioContext.state === 'running') {
            updateUserBeeps();
          }
        }

        function latLonToMidi(lat, lon) {
          if (typeof lat !== 'number' || typeof lon !== 'number' || isNaN(lat) || isNaN(lon)) {
            console.warn('Invalid coordinates provided to latLonToMidi');
            return 60;
          }
          const safeLat = Math.max(-90, Math.min(90, lat));
          const safeLon = Math.max(-180, Math.min(180, lon));
          const normLat = (safeLat + 90) / 180;
          const degreeIndex = Math.floor(normLat * currentScale.value.length) % currentScale.value.length;
          const normLon = (safeLon + 180) / 360;
          const octave = Math.min(2, Math.floor(normLon * 3));
          const midiNote = rootNote + currentScale.value[degreeIndex] + (12 * octave);
          if (midiNote < 0 || midiNote > 127 || !Number.isInteger(midiNote)) {
            console.warn(`Calculated invalid MIDI note: ${midiNote} from lat ${lat}, lon ${lon}`);
            return 60;
          }
          return midiNote;
        }

        function initAudio() {
          audioState.value = 'Waiting for user interaction';
        }

        function enableAudio() {
          if (!audioContext) {
            try {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
              audioState.value = 'Initialized (suspended)';
            } catch (error) {
              console.error('AudioContext error:', error);
              audioState.value = 'Initialization failed';
              return;
            }
          }
          audioContext.resume().then(() => {
            console.log('AudioContext resumed successfully');
            audioState.value = 'Running';
            showAudioPermission.value = false;
            if (soundEnabled.value) {
              updateUserBeeps();
            }
          }).catch(error => {
            console.error('Failed to resume AudioContext:', error);
            audioState.value = 'Resume failed';
          });
          const buffer = audioContext.createBuffer(1, 1, 22050);
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(audioContext.destination);
          source.start(0);
          source.stop(audioContext.currentTime + 0.1);
        }

        function resumeAudioContext() {
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('AudioContext resumed successfully');
              audioState.value = 'Running';
              showAudioPermission.value = false;
              if (soundEnabled.value) {
                updateUserBeeps();
              }
            }).catch(console.error);
          }
        }

        function generateSoundProfile(userId, userName) {
          const frequency = Math.floor(Math.random() * (2000 - 400 + 1)) + 400;
          const bpm = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
          const waveType = ['sine', 'triangle'][Math.floor(Math.random() * 2)];
          const pan = parseFloat((Math.random() * 1.5 - 0.75).toFixed(2));
          const profile = { id: userId, name: userName, frequency, bpm, waveType, pan };
          console.log(`[SOUND PROFILE] ${userName} → ${frequency}Hz, ${bpm} BPM, ${waveType}, pan ${pan}`);
          userSoundProfiles.set(userId, profile);
          return profile;
        }

        function playBeep(profile, distance) {
          if (!audioContext || !soundEnabled.value || audioContext.state !== 'running') {
            console.warn('playBeep skipped — audio not ready');
            return;
          }
          const midiNote = latLonToMidi(profile.latitude, profile.longitude);
          let frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
          frequency = Math.max(20, Math.min(20000, frequency));
          if (isNaN(frequency) || !isFinite(frequency)) {
            console.warn('Invalid frequency calculated, using default');
            frequency = 440;
          }
          let gainValue = 0.2 * (1 - distance / 5000);
          gainValue = Math.max(0, Math.min(1, gainValue));
          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const panner = audioContext.createStereoPanner();
            osc.type = profile.waveType || 'sine';
            osc.frequency.value = frequency;
            gain.gain.value = gainValue;
            panner.pan.value = profile.pan || 0;
            osc.connect(gain).connect(panner).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
            const existingProfileIndex = activeSoundProfiles.value.findIndex(p => p.id === profile.id);
            if (existingProfileIndex >= 0) {
              activeSoundProfiles.value[existingProfileIndex].frequency = frequency;
            } else {
              activeSoundProfiles.value.push({
                id: profile.id,
                name: profile.name,
                frequency: frequency,
                bpm: profile.bpm
              });
            }
          } catch (error) {
            console.error('Audio playback error:', error);
          }
        }

        function playPokeSound() {
          if (!audioContext || !soundEnabled.value || audioContext.state !== 'running') return;
          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.value = 0.5;
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            osc.connect(gain).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
          } catch (error) {
            console.error('Poke sound error:', error);
          }
        }

        function playNewUserSound() {
          if (!audioContext || !soundEnabled.value || audioContext.state !== 'running') {
            console.warn('playNewUserSound skipped — audio not ready');
            return;
          }
          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 1000;
            gain.gain.value = 0.3;
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            osc.connect(gain).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
          } catch (error) {
            console.error('playNewUserSound error:', error);
            errorMessage.value = 'Failed to play new user sound: ' + error.message;
          }
        }

        function playMessageSound() {
          if (!soundEnabled.value) return;
          try {
            const audio = document.querySelector('.message-alert-sound');
            if (audio) {
              audio.currentTime = 0;
              audio.play().catch(e => console.log('Audio play prevented:', e));
            }
          } catch (error) {
            console.error('Message sound error:', error);
          }
        }

        function updateUserBeeps() {
          console.log('[updateUserBeeps] Running...');
          userBeepIntervals.forEach((interval, userId) => {
            clearInterval(interval);
            userBeepIntervals.delete(userId);
          });
          activeSoundProfiles.value = [];
          if (!soundEnabled.value || !audioContext) {
            console.warn('[updateUserBeeps] Audio not ready');
            return;
          }
          if (audioContext.state === 'suspended') {
            resumeAudioContext();
            return;
          }
          const usersToProcess = groupUsers.value.length ? groupUsers.value : nearbyUsers.value;
          usersToProcess.forEach(user => {
            console.log(`[updateUserBeeps] Checking user: ${user.name}, ${user.distance.toFixed(2)}m away`);
            if (user.distance <= 5 && user.id !== selectedUser.value?.id && user.status === 'ONLINE') {
              const profile = generateSoundProfile(user.id, user.name);
              const interval = 60000 / profile.bpm;
              playBeep(profile, user.distance);
              const intervalId = setInterval(() => playBeep(profile, user.distance), interval);
              userBeepIntervals.set(user.id, intervalId);
              activeSoundProfiles.value.push(profile);
            }
          });
        }

        function toggleSound() {
          soundEnabled.value = !soundEnabled.value;
          if (soundEnabled.value) {
            if (!audioContext) {
              enableAudio();
            } else if (audioContext.state === 'suspended') {
              audioContext.resume().then(() => {
                updateUserBeeps();
              });
            } else {
              updateUserBeeps();
            }
          } else {
            userBeepIntervals.forEach(interval => clearInterval(interval));
            userBeepIntervals.clear();
            activeSoundProfiles.value = [];
          }
        }

        setInterval(() => {
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              audioState.value = 'Running';
              showAudioPermission.value = false;
            }).catch(console.error);
          }
        }, 3000);

function initMap(location, retries = 5, delay = 500) {
  waitForLeaflet(() => {
    try {
      nextTick(() => {
        const mapElement = document.getElementById('map');
        if (!mapElement) {
          if (retries > 0) {
            console.warn(`Map container not found, retrying ${retries} more times`);
            setTimeout(() => initMap(location, retries - 1, delay), delay);
            return;
          }
          console.error('Map container not found after retries');
          errorMessage.value = 'Map container not found in DOM';
          return;
        }

        if (map) {
          console.warn('Map already initialized, updating location');
          const option = distanceOptions.value.find(opt => opt.value === selectedDistance.value);
          const zoomLevel = option ? option.zoom : 18;
          map.setView(location, zoomLevel);
          map.invalidateSize();
          return;
        }

        const initialLocation = (location && isValidCoordinate(location[0]) && isValidCoordinate(location[1]))
          ? location
          : [51.505, -0.09];
        const initialZoom = option ? option.zoom : 13;

        map = L.map('map', { zoomControl: true }).setView(initialLocation, initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
          maxZoom: 19
        }).addTo(map);

        if (user.value && isValidCoordinate(location[0]) && isValidCoordinate(location[1])) {
          userMarker = L.marker(location, {
            icon: L.divIcon({
              html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
              className: 'user-marker blinking-marker',
              iconSize: [20, 20]
            })
          }).addTo(map).bindPopup(`<b>${user.value}</b><br>Your location`);
        }

        mapInitialized.value = true;
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 100);
      });
    } catch (error) {
      console.error('Map initialization failed:', error);
      if (retries > 0) {
        console.warn(`Retrying map initialization, ${retries} attempts left`);
        setTimeout(() => initMap(location, retries - 1, delay), delay);
      } else {
        errorMessage.value = 'Map initialization failed after retries: ' + error.message;
      }
    }
  });
}
        function selectUser(user) {
          selectedUser.value = user;
          if (selectedUserMarker && map) {
            map.removeLayer(selectedUserMarker);
          }
          if (map) {
            selectedUserMarker = L.marker([user.latitude, user.longitude], {
              icon: L.divIcon({
                html: `<div style="background-color: #28a745; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.name.charAt(0).toUpperCase()}</div>`,
                className: 'selected-user-marker',
                iconSize: [20, 20]
              })
            }).addTo(map).bindPopup(`<b>${user.name}</b><br>${user.distance < 1000 ? user.distance + 'm' : (user.distance/1000).toFixed(1) + 'km'} away`);
            
            map.setView([user.latitude, user.longitude], 18);
          }
          if (soundEnabled.value && audioContext && audioContext.state === 'running') {
            updateUserBeeps();
          }
        }

        function toggleFollow(user) {
          if (followedUserId.value === user.id) {
            followedUserId.value = null;
            followedUserName.value = '';
            followedUserLocation.value = null;
            if (map && userLocation.value) {
              map.setView(userLocation.value, 18);
              if (selectedUserMarker) {
                map.removeLayer(selectedUserMarker);
                selectedUserMarker = null;
              }
              selectedUser.value = null;
            }
          } else {
            followedUserId.value = user.id;
            followedUserName.value = user.name;
            followedUserLocation.value = [user.latitude, user.longitude];
            if (map && followedUserLocation.value) {
              map.setView(followedUserLocation.value, 18);
              if (selectedUserMarker) {
                map.removeLayer(selectedUserMarker);
              }
              selectedUserMarker = L.marker(followedUserLocation.value, {
                icon: L.divIcon({
                  html: `<div style="background-color: #007bff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.name.charAt(0).toUpperCase()}</div>`,
                  className: 'followed-user-marker blinking-marker',
                  iconSize: [20, 20]
                })
              }).addTo(map).bindPopup(`<b>${user.name}</b> (Following)<br>${user.distance < 1000 ? user.distance + 'm' : (user.distance/1000).toFixed(1) + 'km'} away`);
            }
          }
          updateNearbyMarkers();
        }

function focusOnMyLocation() {
  if (map && userLocation.value) {
    const option = distanceOptions.value.find(opt => opt.value === selectedDistance.value);
    const zoomLevel = option ? option.zoom : 18;
    map.setView(userLocation.value, zoomLevel);
    selectedUser.value = null;
    followedUserId.value = null;
    followedUserName.value = '';
    followedUserLocation.value = null;
    if (selectedUserMarker) {
      map.removeLayer(selectedUserMarker);
      selectedUserMarker = null;
    }
    if (userMarker) {
      userMarker.setIcon(L.divIcon({
        html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
        className: 'user-marker blinking-marker',
        iconSize: [20, 20]
      }));
      userMarker.addTo(map).bringToFront();
    }
  }
  if (soundEnabled.value && audioContext && audioContext.state === 'running') {
    updateUserBeeps();
  }
  updateNearbyMarkers();
}

        function updateNearbyMarkers() {
  if (!map) return;
  nearbyMarkers.forEach(marker => map.removeLayer(marker));
  nearbyMarkers = [];
  const usersToDisplay = groupUsers.value.length 
    ? groupUsers.value.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000)
    : nearbyUsers.value.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000);
  
  nearbyMarkers = usersToDisplay.map((user, index) => {
    const color = followedUserId.value === user.id ? '#007bff' : colors[index % colors.length];
    const distanceText = user.distance === null ? 'Global user' : 
                         (user.distance < 1000 ? `${user.distance}m` : `${(user.distance/1000).toFixed(1)}km`);
    
    return L.marker([user.latitude, user.longitude], {
      icon: L.divIcon({
        html: `<div style="background-color: ${color}; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.name.charAt(0).toUpperCase()}</div>`,
        className: 'user-marker',
        iconSize: [20, 20]
      })
    }).addTo(map).bindPopup(`<b>${user.name}</b>${followedUserId.value === user.id ? ' (Following)' : ''}<br>${distanceText} away`);
  });

  if (followedUserId.value && !usersToDisplay.find(u => u.id === followedUserId.value)) {
    followedUserId.value = null;
    followedUserName.value = '';
    followedUserLocation.value = null;
    if (map && userLocation.value) {
      map.setView(userLocation.value, 18);
    }
    if (selectedUserMarker) {
      map.removeLayer(selectedUserMarker);
      selectedUserMarker = null;
    }
    selectedUser.value = null;
  }
}
        async function pokeUser() {
          if (!selectedUser.value || isPokeCooldown.value) return;
          try {
            lastPokeTime.value = Date.now();
            isPokeCooldown.value = true;
            pokeCooldownSeconds.value = 5;
            await db.collection('users').doc(selectedUser.value.id).update({
              lastPoke: {
                from: user.value,
                fromId: currentUserId.value,
                timestamp: new Date().toISOString(),
              }
            });
            console.log(`Poked ${selectedUser.value.name}`);
          } catch (error) {
            errorMessage.value = "Failed to poke user: " + error.message;
          }
        }

        function createGroupFromSelected() {
          const onlineUsers = nearbyUsers.value.filter(
            u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000
          );
   groupUsers.value = onlineUsers.filter(user => selectedUsersForGroup.value.includes(user.id) && user && user.id && user.name);
          selectedUsersForGroup.value = [];
          updateNearbyMarkers();
          if (soundEnabled.value && audioContext && audioContext.state === 'running') {
            updateUserBeeps();
          }
        }

        function clearGroup() {
          groupUsers.value = [];
          selectedUsersForGroup.value = [];
          updateNearbyMarkers();
          if (soundEnabled.value && audioContext && audioContext.state === 'running') {
            updateUserBeeps();
          }
        }

 watch(userLocation, (newLocation) => {
  if (!newLocation) return;
  updateMapLocation(newLocation);
}, { immediate: true });

        watch(nearbyUsers, () => {
          if (!groupUsers.value.length) {
            updateNearbyMarkers();
            if (soundEnabled.value && audioContext && audioContext.state === 'running') {
              updateUserBeeps();
            }
          }
        });

        watch(status, (newStatus, oldStatus) => {
          if (newStatus === 'OFFLINE') {
            userBeepIntervals.forEach(interval => clearInterval(interval));
            userBeepIntervals.clear();
            activeSoundProfiles.value = [];
            groupUsers.value = [];
            selectedUsersForGroup.value = [];
            if (isSharingPosition.value) {
              stopSharingPosition();
            }
            if (map && mapInitialized.value) {
              nearbyMarkers.forEach(marker => map.removeLayer(marker));
              nearbyMarkers = [];
              if (selectedUserMarker) {
                map.removeLayer(selectedUserMarker);
                selectedUserMarker = null;
              }
            }
          }
        });

onMounted(() => {
  firebaseInitialized.value = initializeFirebase();
  if (!firebaseInitialized.value) {
    errorMessage.value = 'Failed to initialize Firebase. Please check your network or Firebase configuration.';
    return;
  }
  initAudio();
nextTick(() => {
    initMap([0, 0]); // Default to [0, 0] with low zoom
    getUserLocation();
  });

auth.onAuthStateChanged((userData) => {
  if (userData) {
    isSignedIn.value = true;
    currentUserId.value = userData.uid;
    // Use stored username if available, otherwise use displayName or 'Anonymous'
    user.value = getStoredUsername() || userData.displayName || 'Anonymous';
    loadMessages();
      db.collection('users').doc(currentUserId.value).onSnapshot((doc) => {
        if (!doc.exists) {
          console.warn('User document does not exist');
          return;
        }
        const data = doc.data();
        if (!data) {
          console.warn('No data in user document');
          return;
        }
        try {
          if (
            data.status === 'ONLINE' &&
            data.lastPoke &&
            data.lastPoke.fromId !== currentUserId.value
          ) {
            alert(`You were poked by ${data.lastPoke.from}!`);
            if (soundEnabled.value) playPokeSound();
            db.collection('users').doc(currentUserId.value).update({
              lastPoke: firebase.firestore.FieldValue.delete()
            }).catch(error => {
              console.error('Failed to clear lastPoke:', error);
            });
          }
          if (
            data.status === 'ONLINE' &&
            data.receivedLocation &&
            data.receivedLocation.fromId !== currentUserId.value
          ) {
            alert(`Received location from ${data.receivedLocation.from}!
                   Lat: ${data.receivedLocation.latitude.toFixed(6)}
                   Lon: ${data.receivedLocation.longitude.toFixed(6)}`);
            if (map) {
              const receivedLoc = [data.receivedLocation.latitude, data.receivedLocation.longitude];
              L.marker(receivedLoc, {
                icon: L.divIcon({
                  html: `<div style="background-color: #ff00ff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${data.receivedLocation.from.charAt(0).toUpperCase()}</div>`,
                  className: 'received-location-marker',
                  iconSize: [20, 20]
                })
              }).addTo(map).bindPopup(`<b>${data.receivedLocation.from}'s Location</b><br>Received`);
              map.setView(receivedLoc, 13);
            }
            db.collection('users').doc(currentUserId.value).update({
              receivedLocation: firebase.firestore.FieldValue.delete()
            }).catch(error => {
              console.error('Failed to clear receivedLocation:', error);
            });
          }
        } catch (error) {
          console.error('Error processing snapshot:', error);
        }
      }, (error) => {
        console.error('Snapshot listener error:', error);
      });
    } else {
      isSignedIn.value = false;
      if (navigator.geolocation) {
        getUserLocation();
      }
    }
  });
});

function initMap(location, retries = 3, delay = 1000) {
  waitForLeaflet(() => {
    try {
      nextTick(() => {
        if (!document.getElementById('map')) {
          if (retries > 0) {
            console.warn(`Map container not found, retrying ${retries} more times`);
            setTimeout(() => initMap(location, retries - 1, delay), delay);
            return;
          }
          console.error('Map container not found after retries');
          errorMessage.value = 'Map container not found in DOM';
          return;
        }
        if (map) {
          console.warn('Map already initialized, updating location');
          map.setView(location, 18);
          map.invalidateSize();
          return;
        }

        const initialLocation = (location && isValidCoordinate(location[0]) && isValidCoordinate(location[1]))
          ? location
          : [51.505, -0.09];
        const initialZoom = (location && isValidCoordinate(location[0]) && isValidCoordinate(location[1])) ? 18 : 13;

        map = L.map('map').setView(initialLocation, initialZoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
          maxZoom: 19
        }).addTo(map);

        if (user.value && isValidCoordinate(location[0]) && isValidCoordinate(location[1])) {
          userMarker = L.marker(location, {
            icon: L.divIcon({
              html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
              className: 'user-marker blinking-marker',
              iconSize: [20, 20]
            })
          }).addTo(map).bindPopup(`<b>${user.value}</b><br>Your location`);
        }

        mapInitialized.value = true;
        setTimeout(() => {
          if (map) map.invalidateSize();
        }, 100);
      });
    } catch (error) {
      console.error('Map initialization failed:', error);
      if (retries > 0) {
        console.warn(`Retrying map initialization, ${retries} attempts left`);
        setTimeout(() => initMap(location, retries - 1, delay), delay);
      } else {
        errorMessage.value = 'Map initialization failed after retries: ' + error.message;
      }
    }
  });
}
      
async function signIn() {
  try {
    await auth.signInAnonymously();
    isSignedIn.value = true;
    console.log('Signed in anonymously');
    getUserLocation();
  } catch (error) {
    errorMessage.value = 'Sign-in failed: ' + error.message;
  }
}
  
  // signOut function
async function signOut() {
  try {
    await auth.signOut();
    isSignedIn.value = false;
    messages.value = [];
    clearStoredUsername(); // Clear the stored username
    
    if (map) {
      map.remove();
      map = null;
      userMarker = null;
      nearbyMarkers.forEach(marker => marker.remove());
      nearbyMarkers = [];
      if (selectedUserMarker) {
        selectedUserMarker.remove();
        selectedUserMarker = null;
      }
      mapInitialized.value = false;
    }

    user.value = null;
    currentUserId.value = null;
    status.value = 'OFFLINE';
    userLocation.value = null;
    locationStatus.value = 'loading';
  } catch (error) {
    errorMessage.value = 'Sign-out failed: ' + error.message;
  }
}

      function waitForLeaflet(callback) {
  if (typeof L !== 'undefined') {
    callback();
    return;
  }
  const script = document.querySelector('script[src*="leaflet"]');
  if (script) {
    script.addEventListener('load', callback);
  } else {
    setTimeout(() => waitForLeaflet(callback), 100);
  }
}
  
  //  sendMessage function
  async function sendMessage() {
    if (!selectedUser.value || !messageText.value.trim()) return;
    
    try {
      await db.collection('users').doc(selectedUser.value.id).update({
        messages: firebase.firestore.FieldValue.arrayUnion({
          from: user.value,
          fromId: currentUserId.value,
          text: messageText.value,
          timestamp: new Date().toISOString()
        })
      });
      
      messages.value.push({
        from: 'You',
        text: messageText.value,
        timestamp: new Date().toISOString()
      });
      
      messageText.value = '';
    } catch (error) {
      errorMessage.value = "Failed to send message: " + error.message;
    }
  }
  
  //  loadMessages function
function loadMessages() {
  if (!currentUserId.value) return;

  db.collection('users').doc(currentUserId.value).onSnapshot((doc) => {
    if (doc.exists) {
      const data = doc.data();
      if (data.messages) {
        const newIncoming = data.messages
          .filter(msg => msg.fromId !== currentUserId.value)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
          .filter(msg => !messages.value.some(existing => existing.timestamp === msg.timestamp));

        if (newIncoming.length > 0) {
          const latest = newIncoming[newIncoming.length - 1];
          messageAlert.value = { from: latest.from, fromId: latest.fromId };
          showMessageAlert.value = true;

          if (!showMessagePanel.value) {
            unreadMessageCount.value += newIncoming.length;
          }

          setTimeout(() => {
            showMessageAlert.value = false;
          }, 7000); // auto-dismiss after 7 sec

          flashUser(latest.fromId);
          playMessageSound();
        }

        messages.value = [...data.messages.filter(m => m.fromId !== currentUserId.value), ...messages.value.filter(m => m.from === 'You')].slice(-20);
      }
    }
  });
}

      function dismissMessageAlert() {
  showMessageAlert.value = false;
  if (messageAlert.value && messageAlert.value.fromId) {
    const user = nearbyUsers.value.find(u => u.id === messageAlert.value.fromId);
    if (user) {
      selectUser(user);
    }
  }
  messageAlert.value = null;
}

      
function flashUser(userId) {
  nextTick(() => {
    const el = document.querySelector(`[data-user-id="${userId}"]`);
    if (el) {
      el.classList.add('flash-user');
      setTimeout(() => el.classList.remove('flash-user'), 5000);
    }
  });
}


  
  //  clearOldMessages function
  async function clearOldMessages() {
    if (!currentUserId.value) return;
    
    try {
      await db.collection('users').doc(currentUserId.value).update({
        messages: firebase.firestore.FieldValue.delete()
      });
    } catch (error) {
      console.error('Error clearing messages:', error);
    }
  }
  

function getUserLocation() {
  if (!navigator.geolocation) {
    errorMessage.value = 'Geolocation is not supported by your browser';
    locationStatus.value = 'unavailable';
    return;
  }
  
  locationStatus.value = 'loading';
  
  const timeoutDuration = 10000;
  const geoTimeout = setTimeout(() => {
    if (!userLocation.value) {
      locationStatus.value = 'unavailable';
      errorMessage.value = 'Location not available';
      // Initialize map with default location if geolocation fails
      if (!map) initMap([51.505, -0.09]);
    }
  }, timeoutDuration);
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      clearTimeout(geoTimeout);
      userLocation.value = [position.coords.latitude, position.coords.longitude];
      lastLocationUpdate.value = Date.now();
      locationStatus.value = 'acquired';
      errorMessage.value = '';
      updateUserLocation();
      
      // Initialize map if not already done
      if (!map) {
        initMap(userLocation.value);
      } else {
        const option = distanceOptions.value.find(opt => opt.value === selectedDistance.value);
        const zoomLevel = option ? option.zoom : 18;
        map.setView(userLocation.value, zoomLevel);
      }
      
      // Add/update user marker
      if (user.value) {
        if (userMarker) {
          userMarker.setLatLng(userLocation.value);
        } else {
          userMarker = L.marker(userLocation.value, {
            icon: L.divIcon({
              html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
              className: 'user-marker blinking-marker',
              iconSize: [20, 20]
            })
          }).addTo(map).bindPopup(`<b>${user.value}</b><br>Your location`);
        }
      }
      
      // Ensure map is properly sized
      setTimeout(() => {
        if (map) map.invalidateSize();
      }, 100);
      
      if (status.value === 'ONLINE') fetchNearbyUsers();
    },
    (error) => {
      clearTimeout(geoTimeout);
      locationStatus.value = 'unavailable';
      if (error.code === error.PERMISSION_DENIED) {
        errorMessage.value = 'Location access denied. Please enable location services in your browser settings.';
      } else if (error.message.includes('permissions policy')) {
        errorMessage.value = 'Geolocation is disabled by browser permissions policy. Please serve this app over HTTPS or check browser settings.';
      } else {
        errorMessage.value = 'Location not available';
      }
      // Initialize map with default location if geolocation fails
      if (!map) initMap([51.505, -0.09]);
    },
    { timeout: timeoutDuration, enableHighAccuracy: true }
  );
}

        async function updateUserLocation() {
          if (currentUserId.value && userLocation.value) {
            try {
              await db.collection('users').doc(currentUserId.value).set({
                name: user.value,
                status: status.value,
                latitude: userLocation.value[0],
                longitude: userLocation.value[1],
                lastSeen: new Date().toISOString()
              }, { merge: true });
            } catch (error) {
              errorMessage.value = 'Failed to update location: ' + error.message;
            }
          }
        }

        async function toggleStatus() {
          const previousStatus = status.value;
          status.value = status.value === 'ONLINE' ? 'OFFLINE' : 'ONLINE';
          await updateUserLocation();
          
          if (status.value === 'ONLINE' && previousStatus === 'OFFLINE') {
            nearbyUsers.value = [];
            groupUsers.value = [];
            selectedUsersForGroup.value = [];
            followedUserId.value = null;
            followedUserName.value = '';
            followedUserLocation.value = null;
            selectedUser.value = null;
            
            if (map && mapInitialized.value) {
              nearbyMarkers.forEach(marker => map.removeLayer(marker));
              nearbyMarkers = [];
              if (selectedUserMarker) {
                map.removeLayer(selectedUserMarker);
                selectedUserMarker = null;
              }
              if (userLocation.value && userMarker) {
                userMarker.setLatLng(userLocation.value);
                map.setView(userLocation.value, 18);
                map.invalidateSize();
              }
            }
            
            if (userLocation.value) {
              fetchNearbyUsers();
            }
            
            if (groupAlertCheckInterval.value) {
              clearInterval(groupAlertCheckInterval.value);
              groupAlertCheckInterval.value = null;
            }
            
            if (soundEnabled.value && audioContext && audioContext.state === 'running') {
              updateUserBeeps();
            }
          } else if (status.value === 'OFFLINE') {
            nearbyUsers.value = [];
            userBeepIntervals.forEach(interval => clearInterval(interval));
            userBeepIntervals.clear();
            activeSoundProfiles.value = [];
            groupUsers.value = [];
            selectedUsersForGroup.value = [];
            if (isSharingPosition.value) {
              stopSharingPosition();
            }
            if (map && mapInitialized.value) {
              nearbyMarkers.forEach(marker => map.removeLayer(marker));
              nearbyMarkers = [];
              if (selectedUserMarker) {
                map.removeLayer(selectedUserMarker);
                selectedUserMarker = null;
              }
            }
          }
        }

     function selectDistance(distance) {
  selectedDistance.value = distance;
  if (status.value === 'ONLINE') {
    fetchNearbyUsers();
  }
  // Update map zoom if we have a location
  if (map && userLocation.value) {
    const option = distanceOptions.value.find(opt => opt.value === distance);
    if (option) {
      map.setView(userLocation.value, option.zoom);
    }
  }
}

async function changeName() {
  const currentName = user.value || getStoredUsername();
  const newName = prompt('Enter new name:', currentName);
  if (newName) {
    user.value = newName;
    storeUsername(newName); // Store in localStorage
    lastKnownUsernames.value[currentUserId.value] = newName;
    await updateUserLocation();
    if (userMarker) {
      userMarker.setIcon(L.divIcon({
        html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${newName.charAt(0).toUpperCase()}</div>`,
        className: 'user-marker blinking-marker',
        iconSize: [20, 20]
      }));
      userMarker.bindPopup(`<b>${newName}</b><br>Your location`);
    }
  }
}

        function calculateDistance(coord1, coord2) {
          const R = 6371e3;
          const lat1 = coord1[0] * Math.PI / 180;
          const lat2 = coord2[0] * Math.PI / 180;
          const deltaLat = (coord2[0] - coord1[0]) * Math.PI / 180;
          const deltaLon = (coord2[1] - coord1[1]) * Math.PI / 180;
          const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

 async function fetchNearbyUsers() {
  if (!userLocation.value && selectedDistance.value !== Infinity) {
    errorMessage.value = 'Location not available';
    return;
  }
  nearbyUsers.value = [];
  loadingNearby.value = true;
  try {
    const q = db.collection('users').where('status', '==', 'ONLINE');
    q.onSnapshot((snapshot) => {
      const currentUsers = snapshot.docs
        .filter(doc => {
          const data = doc.data();
          return doc.id !== currentUserId.value && 
                 isValidCoordinate(data.latitude) && 
                 isValidCoordinate(data.longitude);
        })
        .map(doc => {
          const data = doc.data();
          const distance = selectedDistance.value === Infinity ? 
            null : 
            calculateDistance(userLocation.value, [data.latitude, data.longitude]);
          const userName = lastKnownUsernames.value[doc.id] || data.name;
          return { 
            id: doc.id, 
            name: userName, 
            distance, 
            lastSeen: data.lastSeen,
            latitude: data.latitude,
            longitude: data.longitude,
            status: data.status
          };
        })
        .filter(user => 
          (selectedDistance.value === Infinity || 
           (user.distance < selectedDistance.value)) && 
          user.status === 'ONLINE' && 
          (Date.now() - Date.parse(user.lastSeen)) < 3600000
        );
      
      nearbyUsers.value = currentUsers.filter(user => user && user.id && user.name);
      loadingNearby.value = false;
      updateNearbyMarkers();
    }, (error) => {
      errorMessage.value = 'Failed to load nearby users: ' + error.message;
      loadingNearby.value = false;
    });
  } catch (error) {
    errorMessage.value = 'Failed to query nearby users: ' + error.message;
    loadingNearby.value = false;
  }
}

        async function cleanInvalidUserLocations() {
          try {
            const snapshot = await db.collection('users').get();
            const batch = db.batch();
            snapshot.forEach(doc => {
              const data = doc.data();
              if (!isValidCoordinate(data.latitude) || !isValidCoordinate(data.longitude)) {
                console.log('Cleaning invalid location for user:', doc.id, data.name);
                batch.update(doc.ref, {
                  latitude: 0,
                  longitude: 0
                });
              }
            });
            await batch.commit();
            console.log('Finished cleaning invalid locations');
          } catch (error) {
            errorMessage.value = 'Failed to clean invalid locations: ' + error.message;
          }
        }

     function processUserData(userData) {
  if (!userData || !isValidCoordinate(userData.latitude) || !isValidCoordinate(userData.longitude)) {
    console.warn('Invalid user location data:', userData);
    return null;
  }
  return {
    id: userData.id,
    name: userData.name || 'Anonymous',
    latitude: userData.latitude,
    longitude: userData.longitude,
  };
}

        function isValidCoordinate(coord) {
          return typeof coord === 'number' && 
                 !isNaN(coord) && 
                 isFinite(coord) &&
                 (Math.abs(coord) <= 180);
        }

        function formatRelativeTime(timestamp) {
          const now = new Date();
          const date = new Date(timestamp);
          const diff = (now - date) / 1000;
          if (diff < 60) return `${Math.floor(diff)} seconds ago`;
          if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
          return `${Math.floor(diff / 3600)} hours ago`;
        }

        function forceRefresh() {
          if (map) {
            map.remove();
            map = null;
            userMarker = null;
            nearbyMarkers.forEach(marker => marker.remove());
            nearbyMarkers = [];
            if (selectedUserMarker) {
              selectedUserMarker.remove();
              selectedUserMarker = null;
            }
            mapInitialized.value = false;
          }
          getUserLocation();
          if (status.value === 'ONLINE') fetchNearbyUsers();
        }

        return {
          user,
          status,
          enableGroupAlerts,
          groupAlertDistance,
          groupAlertMessage,
          checkGroupDistances,
          currentUserId,
          userLocation,
          lastLocationUpdate,
          nearbyUsers,
          loadingNearby,
          errorMessage,
          firebaseInitialized,
          soundEnabled,
          clearingStaleLocations,
          mapInitialized,
          selectedUser,
          activeSoundProfiles,
          showAudioPermission,
          audioState,
          distanceOptions,
          selectedDistance,
          currentScaleName,
          isPokeCooldown,
          pokeCooldownSeconds,
          toggleStatus,
          changeName,
          toggleSound,
          selectUser,
          focusOnMyLocation,
          formatRelativeTime,
          forceRefresh,
          enableAudio,
          selectDistance,
          updateScale,
          pokeUser,
          sendLocation,
          toggleFollow,
          locationStatus,
          followedUserId,
          followedUserName,
          followedUserLocation,
          groupUsers,
          createGroupFromSelected,
          clearGroup,
          sharePosition,
          stopSharingPosition,
          isSharingPosition,
          lastKnownUsernames,
          showHelp,
          toggleHelp,
          selectedUsersForGroup,
            showDebugPanel,
            toggleDebugPanel,
              isSignedIn,
              getStoredUsername,
  storeUsername,
  clearStoredUsername,
    messageText,
    messages,
    signIn,
    signOut,
    sendMessage,
    showMessagePanel,
    toggleMessagePanel,
    unreadMessageCount,
    clearMessages,
    panelMessageText,
    sendPanelMessage,
    messageRecipientType,
    selectedMessageRecipient,
    messageAlert,
    showMessageAlert,
    dismissMessageAlert
        };
      }
    }).mount('#app');
  </script>
</body>
</html>