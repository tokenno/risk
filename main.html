<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FCK DOT</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    margin: 0;
    padding: 10px;
    background-color: #1a1a1a;
    color: #e0e0e0;
  }
  .container {
    max-width: 700px;
    margin: 0 auto;
    background: #2c2c2c;
    border-radius: 6px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
  }
  .section {
    margin-bottom: 15px;
    padding: 15px;
    border: 1px solid #444;
    border-radius: 4px;
    background: #333;
  }
  h3 {
    margin: 0 0 12px;
    font-size: 1.1em;
    color: #fff;
  }
  button {
    padding: 8px 12px;
    background: #28a745;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85em;
    transition: background 0.2s;
    margin-right: 8px;
    margin-bottom: 8px;
  }
  button:hover {
    background: #218838;
  }
  button.warning {
    background: #dc3545;
  }
  button.warning:hover {
    background: #c82333;
  }
  button.secondary {
    background: #6c757d;
  }
  button.secondary:hover {
    background: #5a6268;
  }
  .error {
    color: #ff4d4d;
    font-size: 0.8em;
    margin-top: 8px;
  }
  .user-list div {
    padding: 8px;
    border-bottom: 1px solid #444;
    transition: background 0.2s;
    color: #e0e0e0;
    cursor: pointer;
  }
  .user-list div:hover {
    background: #3a3a3a;
  }
  .user-list div.selected {
    background: #3a3a3a;
    border-left: 3px solid #28a745;
  }
  .user-list div:last-child {
    border-bottom: none;
  }
  #map {
    height: 300px; /* Modified: Default height for desktop */
    width: 100%;
    border: 1px solid #555;
    border-radius: 4px;
    margin-top: 8px;
    background: #1a1a1a;
  }
  @media (max-width: 768px) {
    #map {
      height: 60vh; /* Modified: Taller map for mobile portrait view */
    }
  }
  .map-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #888;
  }
  .map-controls {
    margin-top: 8px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .audio-permission {
    background: #444;
    padding: 15px;
    border-radius: 4px;
    margin-bottom: 15px;
    text-align: center;
  }
  .user-info {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .user-info > span {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background-color: #ff0000;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    font-size: 1.2em;
  }
  .user-info > div > div:first-child {
    font-weight: bold;
    margin-bottom: 4px;
  }
  .button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
  }
  button.active {
    background: #218838;
    box-shadow: 0 0 0 2px #28a745;
  }
  .poke-cooldown {
    font-size: 0.8em;
    color: #888;
    margin-top: 5px;
  }
  @media (max-width: 600px) {
    .container {
      padding: 10px;
    }
    .section {
      padding: 12px;
    }
    #map {
      height: 180px; /* Modified: Removed to use 60vh for mobile */
    }
    .button-group {
      flex-direction: column;
    }
    .button-group button {
      width: 100%;
      margin-right: 0;
    }
  }
</style>
</head>
<body>
  <div id="app" class="container">
    <div class="section audio-permission" v-if="showAudioPermission">
      <h3>Audio Permission Required</h3>
      <p>Please tap the button below to enable sound notifications for nearby users</p>
      <button @click="enableAudio">Enable Sound</button>
    </div>

    <div class="section">
      <div v-if="user" class="user-info">
        <span>{{ user.charAt(0).toUpperCase() }}</span>
        <div>
          <div>{{ user }}</div>
          <div v-if="status === 'ONLINE'">Currently online</div>
          <div v-else>Currently offline</div>
        </div>
      </div>
    </div>

    <div class="section">
      <button @click="toggleStatus">{{ status === 'ONLINE' ? 'Go Offline' : 'Go Online' }}</button>
      <button @click="changeName">Change Name</button>
      <button @click="toggleSound">{{ soundEnabled ? 'ðŸ”” Sound On' : 'ðŸ”• Sound Off' }}</button>
    </div>

    <div class="section">
      <h3>Your Location</h3>
      <div v-if="locationStatus === 'loading'">Acquiring your location...</div>
      <div v-else-if="locationStatus === 'unavailable'">Location not available or waiting to load map</div>
      <div v-else>
        <div>Latitude: {{ userLocation[0].toFixed(6) }}</div>
        <div>Longitude: {{ userLocation[1].toFixed(6) }}</div>
        <div id="map">
          <div v-if="!mapInitialized" class="map-loading">Loading map...</div>
        </div>
        <div class="map-controls" v-if="mapInitialized">
          <button class="secondary" @click="focusOnMyLocation">Focus on Me</button>
        </div>
      </div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
    </div>

    <div class="section">
      <h3>Nearby Users ({{ nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000).length }})</h3>
      <div class="button-group">
        <button 
          v-for="distance in distanceOptions" 
          :key="distance.value"
          :class="{ active: selectedDistance === distance.value }"
          @click="selectDistance(distance.value)"
        >
          {{ distance.label }}
        </button>
      </div>
      <button 
        v-if="selectedUser" 
        @click="pokeUser"
        class="secondary"
        :disabled="isPokeCooldown"
      >
        Poke {{ selectedUser.name }}
      </button>
      <div v-if="isPokeCooldown" class="poke-cooldown">
        Poke available in {{ pokeCooldownSeconds }} seconds
      </div>
      <div v-if="loadingNearby">Loading nearby users...</div>
      <div v-if="!loadingNearby && nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000).length === 0">No users nearby</div>
      <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
      <div v-for="user in nearbyUsers.filter(u => u.status === 'ONLINE' && (Date.now() - Date.parse(u.lastSeen)) < 3600000)" 
           :key="user.id" 
           class="user-list"
           :class="{ selected: selectedUser?.id === user.id }"
           @click="selectUser(user)">
        <div>{{ user.name }}</div>
        <div v-if="user.distance < 1000">{{ user.distance }}m away</div>
        <div v-else>{{ (user.distance/1000).toFixed(1) }}km away</div>
        <div>{{ formatRelativeTime(user.lastSeen) }}</div>
      </div>
    </div>

    <div class="section debug">
      <h3>Debug Information</h3>
      <div>Firebase: {{ firebaseInitialized ? 'Connected' : 'Disconnected' }}</div>
      <div>User ID: {{ currentUserId || 'Not set' }}</div>
      <div>Location: {{ userLocation ? 'Valid' : 'Invalid' }}</div>
      <div>Last Update: {{ lastLocationUpdate ? new Date(lastLocationUpdate).toLocaleTimeString() : 'Never' }}</div>
      <div v-if="activeSoundProfiles.length > 0">
        Active sounds: 
        <span v-for="profile in activeSoundProfiles" :key="profile.id">
          {{ profile.name }} ({{ profile.frequency.toFixed(0) }}Hz)
        </span>
      </div>
      <div>Audio State: {{ audioState }}</div>
      <div>
        Musical Scale: 
        <select v-model="currentScaleName" @change="updateScale">
          <option value="pentatonic">Pentatonic</option>
          <option value="major">Major</option>
          <option value="minor">Minor</option>
          <option value="chromatic">Chromatic</option>
        </select>
      </div>
      <button @click="forceRefresh">Force Refresh</button>
    </div>
  </div>

  <script>
    const { createApp, ref, onMounted, watch, nextTick } = Vue;

    const firebaseConfig = {
      apiKey: "AIzaSyDC6w15EQdfuBTZHlpvoxmaL5ISEgbFAWY",
      authDomain: "risk-ec382.firebaseapp.com",
      projectId: "risk-ec382",
      storageBucket: "risk-ec382.appspot.com",
      messagingSenderId: "177105151944",
      appId: "1:177105151944:web:758b928eb83ccb894902fd",
      measurementId: "G-2LKEG2N7ZD"
    };

    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    firebase.analytics();

    // Musical scales configuration
    const scales = {
      pentatonic: [0, 2, 4, 7, 9],    // C D E G A
      major: [0, 2, 4, 5, 7, 9, 11],   // C D E F G A B
      minor: [0, 2, 3, 5, 7, 8, 10],   // C D Eb F G Ab Bb
      chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    };
    const rootNote = 60; // Middle C (MIDI 60)

    createApp({
      setup() {
        const user = ref(null);
        const status = ref('OFFLINE');
        const currentUserId = ref(null);
        const userLocation = ref(null);
        const lastLocationUpdate = ref(null);
        const nearbyUsers = ref([]);
        const loadingNearby = ref(false);
        const errorMessage = ref('');
        const firebaseInitialized = ref(true);
        const soundEnabled = ref(true);
        const clearingStaleLocations = ref(false);
        const mapInitialized = ref(false);
        const selectedUser = ref(null);
        const activeSoundProfiles = ref([]);
        const showAudioPermission = ref(false);
        const audioState = ref('Not initialized');
        const distanceOptions = ref([
          { label: '100m', value: 100 },
          { label: '1km', value: 1000 },
          { label: '50km', value: 50000 },
          { label: '150km', value: 150000 },
          { label: '500km', value: 500000 }
        ]);
        const selectedDistance = ref(1000);
        const locationStatus = ref('loading');
        const currentScaleName = ref('pentatonic');
        const currentScale = ref(scales.pentatonic);
        const lastPokeTime = ref(0);
        const isPokeCooldown = ref(false);
        const pokeCooldownSeconds = ref(0);

        let map = null;
        let userMarker = null;
        let nearbyMarkers = [];
        let selectedUserMarker = null;
        let audioContext = null;
        const userBeepIntervals = new Map();
        const userSoundProfiles = new Map();
        const colors = ['#3498db', '#2ecc71', '#e74c3c', '#9b59b6', '#f1c40f', '#1abc9c', '#e67e22'];

        // Poke cooldown timer
        const pokeCooldownInterval = setInterval(() => {
          if (isPokeCooldown.value) {
            const now = Date.now();
            const remaining = Math.ceil((lastPokeTime.value + 5000 - now) / 1000);
            if (remaining > 0) {
              pokeCooldownSeconds.value = remaining;
            } else {
              isPokeCooldown.value = false;
              pokeCooldownSeconds.value = 0;
            }
          }
        }, 200);

        function updateScale() {
          currentScale.value = scales[currentScaleName.value];
          if (soundEnabled.value) {
            updateUserBeeps();
          }
        }

        function latLonToMidi(lat, lon) {
          const normLat = (lat + 90) / 180;
          const normLon = (lon + 180) / 360;
          const degree = Math.floor(normLat * currentScale.value.length) % currentScale.value.length;
          const octave = Math.floor(normLon * 3);
          return rootNote + currentScale.value[degree] + 12 * octave;
        }

        function initAudio() {
          if (!audioContext) {
            try {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
              audioState.value = 'Initialized (suspended)';
              
              if (/Mobi|Android/i.test(navigator.userAgent)) {
                showAudioPermission.value = true;
              } else {
                resumeAudioContext();
              }
            } catch (error) {
              console.error('AudioContext error:', error);
              errorMessage.value = 'Audio initialization failed. Try refreshing the page.';
              audioState.value = 'Initialization failed';
            }
          }
        }

        function resumeAudioContext() {
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('AudioContext resumed successfully');
              audioState.value = 'Running';
              showAudioPermission.value = false;
              if (soundEnabled.value) {
                updateUserBeeps();
              }
            }).catch(error => {
              console.error('Failed to resume AudioContext:', error);
              audioState.value = 'Resume failed';
            });
          }
        }

        function enableAudio() {
          resumeAudioContext();
          const buffer = audioContext.createBuffer(1, 1, 22050);
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(audioContext.destination);
          source.start(0);
          source.stop(audioContext.currentTime + 0.1);
        }

        function generateSoundProfile(userId, userName) {
          const frequency = Math.floor(Math.random() * (2000 - 400 + 1)) + 400;
          const bpm = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
          const waveType = ['sine', 'triangle'][Math.floor(Math.random() * 2)];
          const pan = parseFloat((Math.random() * 1.5 - 0.75).toFixed(2));

          const profile = {
            id: userId,
            name: userName,
            frequency,
            bpm,
            waveType,
            pan,
          };

          console.log(`[SOUND PROFILE] ${userName} â†’ ${frequency}Hz, ${bpm} BPM, ${waveType}, pan ${pan}`);
          userSoundProfiles.set(userId, profile);
          return profile;
        }

        function playBeep(profile, distance) {
          if (!audioContext || !soundEnabled.value || audioContext.state !== 'running') {
            console.warn('playBeep skipped â€” audio not ready');
            return;
          }

          // Convert GPS to musical note
          const midiNote = latLonToMidi(profile.latitude, profile.longitude);
          const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);

          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const panner = audioContext.createStereoPanner();

            osc.type = profile.waveType || 'sine';
            osc.frequency.value = frequency;
            gain.gain.value = 0.2 * (1 - distance / 5000);
            panner.pan.value = profile.pan || 0;

            osc.connect(gain).connect(panner).connect(audioContext.destination);

            osc.start();
            osc.stop(audioContext.currentTime + 0.5);

            // Update debug info
            const existingProfileIndex = activeSoundProfiles.value.findIndex(p => p.id === profile.id);
            if (existingProfileIndex >= 0) {
              activeSoundProfiles.value[existingProfileIndex].frequency = frequency;
            } else {
              activeSoundProfiles.value.push({
                id: profile.id,
                name: profile.name,
                frequency: frequency,
                bpm: profile.bpm
              });
            }
          } catch (error) {
            console.error('Audio playback error:', error);
          }
        }

        function playPokeSound() {
          if (!audioContext || !soundEnabled.value || audioContext.state !== 'running') return;
          
          try {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.value = 0.5;
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            osc.connect(gain).connect(audioContext.destination);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
          } catch (error) {
            console.error('Poke sound error:', error);
          }
        }

        function updateUserBeeps() {
          console.log('[updateUserBeeps] Running...');
          userBeepIntervals.forEach((interval, userId) => {
            clearInterval(interval);
            userBeepIntervals.delete(userId);
          });
          activeSoundProfiles.value = [];

          if (!soundEnabled.value || !audioContext || audioContext.state !== 'running') {
            console.warn('[updateUserBeeps] Audio not ready');
            return;
          }

          nearbyUsers.value.forEach(user => {
            console.log(`[updateUserBeeps] Checking user: ${user.name}, ${user.distance.toFixed(2)}m away`);
            if (user.distance <= 5 && user.id !== selectedUser.value?.id && user.status === 'ONLINE') {
              const profile = generateSoundProfile(user.id, user.name);
              const interval = 60000 / profile.bpm;

              playBeep(profile, user.distance);
              const intervalId = setInterval(() => playBeep(profile, user.distance), interval);

              userBeepIntervals.set(user.id, intervalId);
              activeSoundProfiles.value.push(profile);
            }
          });
        }

        function toggleSound() {
          soundEnabled.value = !soundEnabled.value;
          if (!soundEnabled.value) {
            userBeepIntervals.forEach(interval => clearInterval(interval));
            userBeepIntervals.clear();
            activeSoundProfiles.value = [];
          } else {
            if (audioContext && audioContext.state === 'suspended') {
              audioContext.resume().then(() => {
                updateUserBeeps();
              });
            } else if (audioContext && audioContext.state === 'running') {
              updateUserBeeps();
            }
          }
        }

        setInterval(() => {
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              audioState.value = 'Running';
              showAudioPermission.value = false;
              updateUserBeeps();
            }).catch(console.error);
          }
        }, 3000);

        function initMap(location) {
          try {
            nextTick(() => {
              if (!document.getElementById('map')) {
                throw new Error('Map container not found');
              }
              
              map = L.map('map').setView(location, 13);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 18
              }).addTo(map);
              
              userMarker = L.marker(location, {
                icon: L.divIcon({
                  html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.value.charAt(0).toUpperCase()}</div>`,
                  className: 'user-marker',
                  iconSize: [20, 20]
                })
              }).addTo(map).bindPopup(`<b>${user.value}</b><br>Your location`);
              
              mapInitialized.value = true;
            });
          } catch (error) {
            errorMessage.value = 'Map initialization failed: ' + error.message;
          }
        }

        function updateMapLocation(location) {
          if (map) {
            map.setView(location, 13);
            if (userMarker) {
              userMarker.setLatLng(location);
            }
          } else {
            initMap(location);
          }
          // Ensure map is redrawn
          if (map) {
            map.invalidateSize();
          }
        }

        function selectUser(user) {
          selectedUser.value = user;
          
          if (selectedUserMarker && map) {
            map.removeLayer(selectedUserMarker);
          }
          
          if (map) {
            selectedUserMarker = L.marker([user.latitude, user.longitude], {
              icon: L.divIcon({
                html: `<div style="background-color: #28a745; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.name.charAt(0).toUpperCase()}</div>`,
                className: 'selected-user-marker',
                iconSize: [20, 20]
              })
            }).addTo(map).bindPopup(`<b>${user.name}</b><br>${user.distance < 1000 ? user.distance + 'm' : (user.distance/1000).toFixed(1) + 'km'} away`);
            
            map.setView([user.latitude, user.longitude], 13);
          }
          updateUserBeeps();
        }

        function focusOnMyLocation() {
          if (map && userLocation.value) {
            map.setView(userLocation.value, 13);
            selectedUser.value = null;
            
            if (selectedUserMarker) {
              map.removeLayer(selectedUserMarker);
              selectedUserMarker = null;
            }
            
            if (userMarker) {
              userMarker.addTo(map).bringToFront();
            }
          }
          updateUserBeeps();
        }

        async function pokeUser() {
          if (!selectedUser.value || isPokeCooldown.value) return;

          try {
            lastPokeTime.value = Date.now();
            isPokeCooldown.value = true;
            pokeCooldownSeconds.value = 5;

            await db.collection('users').doc(selectedUser.value.id).update({
              lastPoke: {
                from: user.value,
                fromId: currentUserId.value,
                timestamp: new Date().toISOString(),
              }
            });
            console.log(`Poked ${selectedUser.value.name}`);
          } catch (error) {
            errorMessage.value = "Failed to poke user: " + error.message;
          }
        }

        watch(userLocation, (newLocation) => {
          if (!newLocation) return;
          updateMapLocation(newLocation);
        }, { immediate: true });

        watch(nearbyUsers, (newUsers) => {
          if (map) {
            nearbyMarkers.forEach(marker => map.removeLayer(marker));
            nearbyMarkers = newUsers.filter(u => u.status === 'ONLINE').map((user, index) => {
              const color = colors[index % colors.length];
              return L.marker([user.latitude, user.longitude], {
                icon: L.divIcon({
                  html: `<div style="background-color: ${color}; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${user.name.charAt(0).toUpperCase()}</div>`,
                  className: 'user-marker',
                  iconSize: [20, 20]
                })
              }).addTo(map).bindPopup(`<b>${user.name}</b><br>${user.distance < 1000 ? user.distance + 'm' : (user.distance/1000).toFixed(1) + 'km'} away`);
            });
          }
          updateUserBeeps();
        });

        watch(status, (newStatus) => {
          if (newStatus === 'OFFLINE') {
            userBeepIntervals.forEach(interval => clearInterval(interval));
            userBeepIntervals.clear();
            activeSoundProfiles.value = [];
          }
        });

        onMounted(() => {
          initAudio();
          auth.onAuthStateChanged((userData) => {
            if (userData) {
              currentUserId.value = userData.uid;
              user.value = userData.displayName || 'Anonymous';
              nearbyUsers.value = [];
              getUserLocation();

              // Listen for pokes
              db.collection('users').doc(currentUserId.value).onSnapshot((doc) => {
                const data = doc.data();
                if (data.lastPoke && data.lastPoke.fromId !== currentUserId.value) {
                  alert(`You were poked by ${data.lastPoke.from}!`);
                  if (soundEnabled.value) playPokeSound();
                }
              });
            } else {
              errorMessage.value = 'Please sign in';
              signIn();
            }
          });
        });

        async function signIn() {
          try {
            await auth.signInAnonymously();
            console.log('Signed in anonymously');
          } catch (error) {
            errorMessage.value = 'Anonymous sign-in failed: ' + error.message;
          }
        }

        function getUserLocation() {
          if (!navigator.geolocation) {
            errorMessage.value = 'Geolocation is not supported by your browser';
            locationStatus.value = 'unavailable';
            return;
          }
          locationStatus.value = 'loading';
          const timeoutDuration = 10000;
          const geoTimeout = setTimeout(() => {
            if (!userLocation.value) {
              locationStatus.value = 'unavailable';
              errorMessage.value = 'Location not available or waiting to load map';
            }
          }, timeoutDuration);
          navigator.geolocation.getCurrentPosition(
            (position) => {
              clearTimeout(geoTimeout);
              userLocation.value = [position.coords.latitude, position.coords.longitude];
              lastLocationUpdate.value = Date.now();
              locationStatus.value = 'acquired';
              errorMessage.value = '';
              updateUserLocation();
              if (status.value === 'ONLINE') fetchNearbyUsers();
            },
            (error) => {
              clearTimeout(geoTimeout);
              locationStatus.value = 'unavailable';
              if (error.code === error.PERMISSION_DENIED) {
                errorMessage.value = 'Location access denied. Please enable location services in your browser settings.';
              } else if (error.message.includes('permissions policy')) {
                errorMessage.value = 'Geolocation is disabled by browser permissions policy. Please serve this app over HTTPS or check browser settings.';
              } else {
                errorMessage.value = 'Location not available or waiting to load map';
              }
            },
            { timeout: timeoutDuration, enableHighAccuracy: true }
          );
        }

        async function updateUserLocation() {
          if (currentUserId.value && userLocation.value) {
            try {
              await db.collection('users').doc(currentUserId.value).set({
                name: user.value,
                status: status.value,
                latitude: userLocation.value[0],
                longitude: userLocation.value[1],
                lastSeen: new Date().toISOString()
              }, { merge: true });
            } catch (error) {
              errorMessage.value = 'Failed to update location: ' + error.message;
            }
          }
        }

        async function toggleStatus() {
          status.value = status.value === 'ONLINE' ? 'OFFLINE' : 'ONLINE';
          await updateUserLocation();
          
          nearbyUsers.value = [];
          
          if (status.value === 'ONLINE') {
            fetchNearbyUsers();
          }
        }

        function selectDistance(distance) {
          selectedDistance.value = distance;
          if (status.value === 'ONLINE') {
            fetchNearbyUsers();
          }
        }

        async function changeName() {
          const newName = prompt('Enter new name:', user.value);
          if (newName) {
            user.value = newName;
            await updateUserLocation();
            if (userMarker) {
              userMarker.setIcon(L.divIcon({
                html: `<div style="background-color: #ff0000; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${newName.charAt(0).toUpperCase()}</div>`,
                className: 'user-marker',
                iconSize: [20, 20]
              }));
              userMarker.bindPopup(`<b>${newName}</b><br>Your location`);
            }
          }
        }

        function calculateDistance(coord1, coord2) {
          const R = 6371e3;
          const lat1 = coord1[0] * Math.PI / 180;
          const lat2 = coord2[0] * Math.PI / 180;
          const deltaLat = (coord2[0] - coord1[0]) * Math.PI / 180;
          const deltaLon = (coord2[1] - coord1[1]) * Math.PI / 180;
          const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        async function fetchNearbyUsers() {
          if (!userLocation.value) {
            errorMessage.value = 'Location not available';
            return;
          }
          
          nearbyUsers.value = [];
          loadingNearby.value = true;
          
          const q = db.collection('users').where('status', '==', 'ONLINE');
          
          q.onSnapshot((snapshot) => {
            const currentUsers = snapshot.docs
              .filter(doc => doc.id !== currentUserId.value)
              .map(doc => {
                const data = doc.data();
                const distance = calculateDistance(userLocation.value, [data.latitude, data.longitude]);
                return { 
                  id: doc.id, 
                  name: data.name, 
                  distance, 
                  lastSeen: data.lastSeen,
                  latitude: data.latitude,
                  longitude: data.longitude,
                  status: data.status
                };
              })
              .filter(user => user.distance < selectedDistance.value && user.status === 'ONLINE');

            nearbyUsers.value = currentUsers;
            loadingNearby.value = false;
            
            if (currentUsers.length > 0 && soundEnabled.value) {
              playNewUserSound();
            }
          }, (error) => {
            errorMessage.value = 'Failed to load nearby users: ' + error.message;
            loadingNearby.value = false;
          });
        }

        function formatRelativeTime(timestamp) {
          const now = new Date();
          const date = new Date(timestamp);
          const diff = (now - date) / 1000;
          if (diff < 60) return `${Math.floor(diff)} seconds ago`;
          if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
          return `${Math.floor(diff / 3600)} hours ago`;
        }

        function forceRefresh() {
          if (map) {
            map.remove();
            map = null;
            userMarker = null;
            nearbyMarkers.forEach(marker => marker.remove());
            nearbyMarkers = [];
            if (selectedUserMarker) {
              selectedUserMarker.remove();
              selectedUserMarker = null;
            }
            mapInitialized.value = false;
          }
          getUserLocation();
          if (status.value === 'ONLINE') fetchNearbyUsers();
        }

        return {
          user,
          status,
          currentUserId,
          userLocation,
          lastLocationUpdate,
          nearbyUsers,
          loadingNearby,
          errorMessage,
          firebaseInitialized,
          soundEnabled,
          clearingStaleLocations,
          mapInitialized,
          selectedUser,
          activeSoundProfiles,
          showAudioPermission,
          audioState,
          distanceOptions,
          selectedDistance,
          currentScaleName,
          isPokeCooldown,
          pokeCooldownSeconds,
          toggleStatus,
          changeName,
          toggleSound,
          selectUser,
          focusOnMyLocation,
          formatRelativeTime,
          forceRefresh,
          enableAudio,
          selectDistance,
          updateScale,
          pokeUser,
          locationStatus
        };
      }
    }).mount('#app');
  </script>
</body>
</html>